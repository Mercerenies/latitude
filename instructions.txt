
One-byte opcodes, followed by whatever arguments the system expects
 - STR String arguments are encoded in the obvious way, concluded by a null terminator
 - INT Integer arguments are encoded using four bytes, in little endian byte order
       (begins with a single "sign byte")
 - REG Registers have their own indices and occupy one byte for storage
 - SPC "Special" instruction arguments
   * (1 byte n) (n bytes L) (L bytes content)

 == ObjectPtr ==
%ptr (01) - Working register, holds an ObjectPtr
%slf (02) - The self ObjectPtr, used for method calls and lookups
%ret (03) - The return value register, holds an ObjectPtr

 == Stack of ObjectPtr ==
%lex (04) - A stack of lexical scopes
%dyn (05) - A stack of dynamic scopes
%arg (06) - The current argument list (the bottom of the stack is $1)
%sto (07) - General-purpose storage stack for intermediate computations

 == Continuation ==
%cont (08) - The current continuation (a sequence of instructions)
%stack (09) - The continuation stack

 == Etc ==
%err0 (0A) - A boolean value that gets set by some computations if they err
%err1 (0B) - Can be swapped with %err0 for storage of error status
%sym (0C) - A symbol
%num0 (0D) - A number
%num1 (0E) - Another number
%str0 (0F) - A string
%str1 (10) - Another string
%mthd (11) - A method (sequence of instructions)
%cpp (12) - A table of C++ function calls, indexed by integers
%strm (13) - A stream pointer
%prcs (14) - A process pointer
%mthdz (15) - An extra method
%flag (16) - An arbitrary boolean value
%wind (17) - A stack of "wind frames" (thunk pairs)

 == Stack of ObjectPtr ==
%hand (18) - A stack of exception handlers

mov SRC DEST (01 REG REG) - For ObjectPtr registers only, move from src to dest
push PTR STACK (02 REG REG) - Push ObjectPtr onto ObjectPtr stack
pop STACK (03 REG) - Pop from stack into %ptr, sets %err0 if empty

getl (04) - Get the top of %lex and put it in %ptr without popping, sets %err0 if empty
getd (05) - Get the top of %dyn and put it in %ptr without popping, sets %err0 if empty

eswap (06) - Swap %err0 and %err1
eclr (07) - Clear %err0
eset (08) - Set %err0

sym STRING (09 STR) - Intern the string in the global symbol table and put its symbolic index in %sym
num STRING (0A STR)- Read the string as a big integer into %num0
int INT (0B INT) - Put the small integer into %num0
float STRING (0C STR) - Read the string into a double into %num0
nswap (0D) - Swap %num0 and %num1

call INT (0E INT) - (See below)
xcall (0F) - (See below)
xcall0 INT (10 INT) - (See below)
ret (11) - Pop %lex and %dyn, discarding both values, sets %err0 if either is empty

clone (12) - Perform the primitive clone operation on %slf, put result in %ret

rtrv (13) - Lookup the name %sym on %slf and put the value at %ret (may incur a call if `missing` is used)
rtrvd (14) - Retrieve directly; do not look into the parents or `missing` (sets %err0 if not found)

str STRING (15 STR) - Put the string into %str0
sswap (16) - Swap %str0 and %str1

expd (17 REG) - Try to put %ptr's prim() into the register given, %err0 if not possible
mthd (18 SPC) - Put the argument into %mthd
load (19 REG) - Inverse of expd, try to put register into %ptr's prim(), %err0 if invalid register

setf (1A) - Put %ptr into %slf at the %sym slot, sets %err0 if %slf is null
peek (1B REG) - Like pop but don't remove the element; sets %err0 if empty

symn INT (1C INT) - Like sym except grab the symbol with the given index
cpp INT (1D INT) - Call the system function at the specified index in %cpp, set %err0 if invalid

bol (1E) - Put `meta True` or `meta False` into %ret, depending on %flag (Boolean instruction)
test (1F) - Compare %slf and %ptr for equality, store result in %flag
branch (20) - Push %cont on %stack, then move %mthd (if true) or %mthdz (if false) to %cont based on %flag

(Note that the continuation jump instructions, cgoto and cret, resolve the %wind stack as well)
ccall (21) - Store the current continuation in %slf, then push %slf onto %arg and do "call 1L" (uses %ptr)
cgoto (22) - Restore the continuation from %ptr, resolving %wind in the process
cret (23) - Restore continuation from %ptr, store %ret on %sto, resolve %wind, then restore %ret (%slf / %ptr are undefined)

wnd (24) - Push %slf and %ptr (as before and after) onto %wind, sets %err0 if either is non-method
unwnd (25) - Pop %wind and discard the resulting frame

throw (26) - Using %slf as the exception, call all of %hand in sequence (ignoring non-methods), then terminate
throq (27) - Perform the throw instruction if %err0 is true, otherwise do nothing

adds (28) - Take %str0 and append %str1 to it
arith OP (29 INT) - Perform an operation on %num0 and %num1, storing result in %num0, sets %err0 if invalid arg

((( The call instructions )))
1. Check for `closure`; if no `closure`, simply move %ptr to %ret and do not perform any other actions
2. Clone the top of %dyn and put it on %dyn (%err0 and continue with no stack if empty)
3. Push a clone of `closure` onto %lex
4. Bind all of the local lexical variables
5. Pop N args from %arg into %dyn
6. Push %cont onto %stack
7. Make a new %cont based on what needs to be done from %ptr

((( xcall and xcall0 )))
(xcall0) 1. Check for `closure`; if no `closure`, stop
(xcall0) 2. Clone the top of %dyn and put it on %dyn (%err0 and continue with no stack if empty)
(xcall0) 3. Push a clone of `closure` onto %lex
(xcall0) 4. Bind all of the local lexical variables
(xcall0) 5. Pop N args from %arg into %dyn
(xcall ) 6. Push %cont onto %stack
(xcall ) 7. Make a new %cont based on what needs to be done
(Note that xcall is a no-op if %ptr is not a method)

((( arith )))
 - 1L - Addition
 - 2L - Subtraction
 - 3L - Multiplication
 - 4L - Division
 - 5L - Modulo
 - 6L - Power

((( expd / load )))
It can be passed
 - %sym - To convert to sym
 - %str0, %str1 - To convert to string
 - %num0, %num1 - To convert to num
 - %mthd - To convert to method
 - %strm - To convert to stream ptr
 - %prcs - To convert to process ptr
 - %mthdz - To convert to method (as with %mthd)
