
One-byte opcodes, followed by whatever arguments the system expects
 - STR String arguments are encoded in the obvious way, concluded by a null terminator
 - INT Integer arguments are encoded using four bytes, in little endian byte order
       (begins with a single "sign byte")
 - REG Registers have their own indices and occupy one byte for storage
 - SPC "Special" instruction arguments
   * (1 byte n) (n bytes L) (L bytes content)

 == ObjectPtr ==
%ptr (01) - Working register, holds an ObjectPtr
%slf (02) - The self ObjectPtr, used for method calls and lookups
%ret (03) - The return value register, holds an ObjectPtr

 == Stack of ObjectPtr ==
%lex (04) - A stack of lexical scopes
%dyn (05) - A stack of dynamic scopes
%arg (06) - The current argument list (the bottom of the stack is $1)
%sto (07) - General-purpose storage stack for intermediate computations

 == Continuation ==
%cont (08) - The current continuation (a sequence of instructions)
%stack (09) - The continuation stack

 == Etc ==
%err0 (0A) - A boolean value that gets set by some computations if they err
%err1 (0B) - Can be swapped with %err0 for storage of error status
%sym (0C) - A symbol
%num0 (0D) - A number
%num1 (0E) - Another number
%str0 (0F) - A string
%str1 (10) - Another string
%mthd (11) - A method (sequence of instructions)

mov SRC DEST (01 REG REG) - For ObjectPtr registers only, move from src to dest
push PTR STACK (02 REG REG) - Push ObjectPtr onto ObjectPtr stack
pop STACK (03 REG) - Pop from stack into %ptr, sets %err0 if empty

getl (04) - Get the top of %lex and put it in %ptr without popping, sets %err0 if empty
getd (05) - Get the top of %dyn and put it in %ptr without popping, sets %err0 if empty

eswap (06) - Swap %err0 and %err1
eclr (07) - Clear %err0
eset (08) - Set %err0

sym STRING (09 STR) - Intern the string in the global symbol table and put its symbolic index in %sym
num STRING (0A STR)- Read the string as a big integer into %num0
int INT (0B INT) - Put the small integer into %num0
float STRING (0C STR) - Read the string into a double into %num0
nswap (0D) - Swap %num0 and %num1

call INT (0E INT) - Bind N args in %arg (popping them off as well), then call %ptr on %slf, putting result in %ret
xcall (0F) - (Reserved for future use)
xcall0 INT (10 INT) - Bind %arg, then call %ptr on %slf with %ret as the callback, putting result in %ret
ret (11) - Pop %lex and %dyn, discarding both values, sets %err0 if either is empty

clone (12) - Perform the primitive clone operation on %slf, put result in %ret

rtrv (13) - Lookup the name %sym on %slf and put the value at %ret (may incur a call if `missing` is used)
rtrvd (14) - Retrieve directly; do not look into the parents or `missing` (sets %err0 if not found)

str STRING (15 STR) - Put the string into %str0
sswap (16) - Swap %str0 and %str1

expd (17 REG) - Try to put %ptr's prim() into the register given, %err0 if not possible
mthd (18 SPC) - Put the argument into %mthd
load (19 REG) - Inverse of expd, try to put register into %ptr's prim(), %err0 if invalid register

setf (1A) - Put %ptr into %slf at the %sym slot, sets %err0 if %slf is null
peek (1B REG) - Like pop but don't remove the element; sets %err0 if empty

((( The call instructions )))
1. Check for `closure`; if no `closure`, simply move %ptr to %ret and do not perform any other actions
2. Clone the top of %dyn and put it on %dyn (%err0 and continue with no stack if empty)
3. Push a clone of `closure` onto %lex
4. Empty %arg into %dyn
5. Push %cont onto %stack
6. Make a new %cont based on what needs to be done

((( expd )))
It can be passed
 - %sym - To convert to sym
 - %str0, %str1 - To convert to string
 - %num0, %num1 - To convert to num
 - %mthd - To convert to method
