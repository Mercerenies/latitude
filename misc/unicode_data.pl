#!/usr/bin/perl

use strict;
use warnings;
use 5.010;

my @classes = qw{
    Lu Ll Lt Lm Lo Mn Mc Me Nd Nl No Pc Pd
    Ps Pe Pi Pf Po Sm Sc Sk So Zs Zl Zp Cc
    Cf Cs Co Cn
};

my $curr = '';
my $start;
my %classes;
my @data;
my @char_data;

open my $fh, '<', '../misc/uni/UnicodeData.txt';
while (<$fh>) {
    my @line = split /;/;
    if ($curr ne $line[2]) {
        if ($curr ne '') {
            my %value = (
                start => $start  ,
                end   => $line[0],
                class => $curr
                );
            push @data, \%value;
            ++$classes{$curr};
        }
        $start = $line[0];
        $curr = $line[2];
    }
    my $upper = $line[12];
    my $lower = $line[13];
    my $title = $line[14];
    chomp $title; # FML
    if ($upper || $lower || $title) {
        # Cases
        if ($upper) {
            $upper = "0x$upper";
        } else {
            $upper = '-1';
        }
        if ($lower) {
            $lower = "0x$lower";
        } else {
            $lower = '-1';
        }
        if ($title) {
            $title = "0x$title";
        } else {
            $title = '-1';
        }
        my %value = (
            'codepoint' => "0x$line[0]",
            'upper' => $upper,
            'lower' => $lower,
            'title' => $title
            );
        push @char_data, \%value;
    }
}
close($fh);

if ($ARGV[0] eq 'header') {

    local $" = ",\n    ";
    my @enum_contents = map { "UNICLS_@{[uc]}" } @classes;

    print <<"END_CC";

// This file is generated by unicode_data.pl. Do not modify by hand.

#ifndef PL_UNIDATA_H
#define PL_UNIDATA_H

#ifdef __cplusplus
extern "C" {
#endif

enum uni_class_t {
    @enum_contents
};

enum uni_class_t get_class(int codepoint);

int to_upper(int codepoint);
int to_lower(int codepoint);
int to_title(int codepoint);

#ifdef __cplusplus
}
#endif

#endif // PL_UNIDATA_H

END_CC

} elsif ($ARGV[0] eq 'source') {

    local $" = ",\n    ";
    my @block_data = map { "{ 0x$_->{start}, 0x$_->{end}, UNICLS_@{[uc $_->{class}]} }" } @data;
    my @char_code = map { "{ $_->{codepoint}, $_->{lower}, $_->{upper}, $_->{title} }" } @char_data;

    print <<"END_CC";

// This file is generated by unicode_data.pl. Do not modify by hand.

#include "pl_Unidata.h"
#define NULL 0

struct block_data_t {
    long start;
    long end;
    enum uni_class_t class;
};

struct char_data_t {
    long codepoint;
    long lower;
    long upper;
    long title;
};

static struct block_data_t all_block_data[] = {
    @block_data
};
static const int BLOCK_COUNT = @{[scalar @block_data]};

static struct char_data_t all_char_data[] = {
    @char_code
};
static const int CHAR_COUNT = @{[scalar @char_code]};

struct block_data_t* get_block(long codepoint) {
    int begin = 0;
    int end = BLOCK_COUNT;
    while (1) {
        int pivot = (begin + end) / 2;
        if (codepoint < all_block_data[pivot].start) {
            end = pivot;
        } else if (codepoint >= all_block_data[pivot].end) {
            begin = pivot + 1;
        } else {
            return &all_block_data[pivot];
        }
    }
}

struct char_data_t* get_char(long codepoint) {
    int begin = 0;
    int end = CHAR_COUNT;
    while (1) {
        int pivot = (begin + end) / 2;
        if (codepoint < all_char_data[pivot].codepoint) {
            end = pivot;
        } else if (codepoint > all_char_data[pivot].codepoint) {
            begin = pivot + 1;
        } else {
            return &all_char_data[pivot];
        }
        if (begin >= end)
            return NULL;
    }
}

enum uni_class_t get_class(int codepoint) {
    return get_block(codepoint)->class;
}

int to_upper(int codepoint) {
    struct char_data_t* data = get_char(codepoint);
    if (data == NULL)
        return codepoint;
    else if (data->upper == -1)
        return codepoint;
    else
        return (int)data->upper;
}

int to_lower(int codepoint) {
    struct char_data_t* data = get_char(codepoint);
    if (data == NULL)
        return codepoint;
    else if (data->lower == -1)
        return codepoint;
    else
        return (int)data->lower;
}

int to_title(int codepoint) {
    struct char_data_t* data = get_char(codepoint);
    if (data == NULL)
        return codepoint;
    else if (data->title == -1)
        return codepoint;
    else
        return (int)data->title;
}

END_CC

} else {
    die("Unknown argument $ARGV[0]");
}
