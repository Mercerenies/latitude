;;* MODULE repl
;;* PACKAGE base

REPL ::= Object clone.

REPL quitter := {
  jump := Nil.
  setJump := { parent jump := $1. }.
  callCC {
    inner := $1.
    callCC {
      setJump: $1.
      inner call: Nil.
    }.
    Kernel kill.
  }.
  jump.
} me. ; TODO There is definitely a continuation cycle in here; can we eliminate it?
REPL quit := { self quitter call: Nil. }.
REPL scope := global clone.
REPL $scope := Nil. ; To be assigned in-loop
REPL exception := Nil.
REPL lastResult := Nil.
REPL maxObjects := 10000.

global quit := { self REPL quit. }.
global $except := { self REPL exception. }.
global $it := { self REPL lastResult. }.

REPL eof? := {
  stdin eof?.
}.

REPL read := {
  stdout puts: "> ".
  stdin readln.
}.
REPL eval := {
  Kernel eval: self scope, self $scope, $1.
}.
REPL print := {
  stdout println: #'$1.
}.
REPL loop := {
  localize.
  $whereAmI := this.
  self $scope := $dynamic clone.
  loop {
    {
      { this maxObjects is: Number. } and { (Kernel GC total) >= (this maxObjects). } ifTrue {
        Kernel GC run.
        (Kernel GC total) >= (this maxObjects) ifTrue {
          this maxObjects := this maxObjects * 2.
        }.
      }.
      expr := this read.
      (expr == "") and (this eof?) ifTrue {
        stdout putln "".
        this quit.
      }.
      this lastResult := this eval: expr.
      this print: this slot 'lastResult.
    } resolve:
      True,
      {
        this exception := $1.
        stderr putln: "***** EXCEPTION *****".
        stderr putln: this exception pretty.
        {
          this exception slot? 'printStackTrace.
        } ifTrue {
          this exception printStackTrace.
        }.
      }.
  }.
}.

global REPL := REPL.
