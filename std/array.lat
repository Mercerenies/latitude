
;; "Cons" objects, as in Lisp
global Cons := Object clone.
Cons toString := "Cons".
Cons pretty := { chain := { curr := $1.
                            if: curr cdr nil?,
                                { curr car toString. },
                                { if: (curr cdr is: Cons),
                                      { (curr car toString) ++ " " ++ (chain: curr cdr). },
                                      { (curr car toString) ++ " . " ++ (curr cdr toString). }. }. }.
                 "(" ++ (chain: self) ++ ")". }.
Cons car := Nil.
Cons cdr := Nil.

global cons := { cc := Cons clone.
                 cc car := dynamic hold '$1.
                 cc cdr := dynamic hold '$2.
                 cc. }.

Cons := Cons.

;; Array functions
Array lowerBound := 0.
Array upperBound := 0.
Array mapping := { var := $1.
                   if: { var >= 0. },
                       { (var * 2) + 1. },
                       { var * -2. }. }.
Array empty? := { (self lowerBound) >= (self upperBound). }.
Array pushFront := { value := $1.
                     self lowerBound := self lowerBound - 1.
                     self put: (self mapping: self lowerBound) ordinal, value.
                     value. }.
Array pushBack := { value := $1.
                    self put: (self mapping: self upperBound) ordinal, value.
                    self upperBound := self upperBound + 1.
                    value. }.
Array popFront := { if: self empty?,
                        { meta BoundsError clone throw. },
                        { self := parent self.
                          self lowerBound := self lowerBound + 1.
                          self get: (self mapping: (self lowerBound - 1)) ordinal. }. }.
Array popBack := { if: self empty?,
                       { meta BoundsError clone throw. },
                       { self := parent self.
                         self upperBound := self upperBound - 1.
                         self get: (self mapping: self upperBound) ordinal. }. }.
Array nth := { pos := if: ($1 < 0),
                          { (parent self upperBound) + (parent dynamic $1). },
                          { (parent self lowerBound) + (parent dynamic $1). }.
               if: ((pos < (self lowerBound)) or (pos >= (self upperBound))),
                   { meta BoundsError clone throw. },
                   { self := parent self.
                     self get: (self mapping: pos) ordinal. }. }.
Array nth= := { pos := if: ($1 < 0),
                           { (parent self upperBound) + (parent dynamic $1). },
                           { (parent self lowerBound) + (parent dynamic $1). }.
                if: ((pos < (self lowerBound)) or (pos >= (self upperBound))),
                    { meta BoundsError clone throw. },
                    { self := parent self.
                      self put: (self mapping: pos) ordinal, parent dynamic $2. }. }.
Array size := { (self upperBound) - (self lowerBound). }.
Array join := { index := 1.
                size := self size.
                delim := { parent dynamic $1. }.
                str := if: self empty?,
                           { "". },
                           { (parent self nth: 0) toString. }.
                while { (index) < (size). }
                   do { parent str := (str) ++ ((delim) ++ ((parent self nth: index) toString)).
                        parent index := index + 1. }.
                str. }.
Array toString := { "[" ++ (self join ", ") ++ "]". }.
Array == := { localize.
              takes '[arr].
              { arr is: Array. } and
                  { ((this size) == (arr size)) and { (this zip: arr) all: { ($1 car) == ($1 cdr). }. }. }. }.
Array < := { localize.
             takes '[arr].
             callCC { return := { parent dynamic $1 call. }.
                      (arr is: Array) ifFalse { return: False. }.
                      (this zip: arr) visit: { (($1 car) < ($1 cdr)) ifTrue: { return: True. }.
                                               (($1 car) > ($1 cdr)) ifTrue: { return: False. }. }.
                      (this size) < (arr size). }. }.

;; Collection Methods
Array iterator := { ArrayIterator := Object clone.
                    ArrayIterator toString := "ArrayIterator".
                    ArrayIterator index := 0.
                    ArrayIterator array := self.
                    ArrayIterator next := { self index := self index + 1. }.
                    ArrayIterator end? := { (self index) >= (self array size). }.
                    ArrayIterator element := { self array nth: self index. }.
                    ArrayIterator element= := { self array nth=: self index, $1. }.
                    ArrayIterator. }.

;; This is a fix for a problem with `map` from `Collection`
Array clone := { procd := self invoke: (Object hold 'clone).
                 procd call tap { self lowerBound := self lowerBound.
                                  self upperBound := self upperBound. }. }.

;; Array Syntax
meta brackets := { ArrayBuilder := self Object clone.
                   ArrayBuilder toString := "ArrayBuilder".
                   ArrayBuilder array := self Array clone.
                   ArrayBuilder next := { self array pushBack: $1. }.
                   ArrayBuilder finish := { self array. }.
                   ArrayBuilder. }.

;; Return the script
here.