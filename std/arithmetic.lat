
;; Arithmetic and Number Types
Number toString := { meta sys numToString#: self. }.
Number == := { meta sys primEquals#: self, $1. }.
Number < := { if: { parent self isComplex?. } or { parent dynamic $1 isComplex?. },
                  { TypeError clone tap { self message := "Cannot compare complex numbers". } throw. },
                  { meta sys primLT#: parent self, parent dynamic $1. }. }.

Number + := { meta sys numAdd#: self, $1. }.
Number - := { meta sys numSub#: self, $1. }.
Number * := { meta sys numMul#: self, $1. }.
Number / := { meta sys numDiv#: self, $1. }.
Number mod := { if: { parent self isComplex?. } or { parent dynamic $1 isComplex?. },
                    { TypeError clone tap { self message := "Cannot modulo complex numbers". } throw. },
                    { meta sys numMod#: parent self, parent dynamic $1. }. }.
Number ^ := { meta sys numPow#: self, $1. }.

global - := { 0 - ($1). }.
global / := { 1 / ($1). }.

Number floor := { if: { parent self isComplex?. },
                      { TypeError clone tap { self message := "Cannot round complex numbers". } throw. },
                      { meta sys numFloor#: parent self. }. }.
Number round := { (self + 0.5) floor. }.
Number ceil := { - (- (self) floor). }.

;; Trigonometry
Number sin := { meta sys numTrig#: self, 0. }.
Number cos := { meta sys numTrig#: self, 1. }.
Number tan := { meta sys numTrig#: self, 2. }.
Number csc := { / ((self) sin). }.
Number sec := { / ((self) cos). }.
Number cot := { / ((self) tan). }.

Number sinh := { meta sys numTrig#: self, 3. }.
Number cosh := { meta sys numTrig#: self, 4. }.
Number tanh := { meta sys numTrig#: self, 5. }.
Number csch := { / ((self) sinh). }.
Number sech := { / ((self) cosh). }.
Number coth := { / ((self) tanh). }.

Number asin := { meta sys numTrig#: self, 7. }.
Number acos := { meta sys numTrig#: self, 8. }.
Number atan := { meta sys numTrig#: self, 9. }.
Number acsc := { (/ (self)) asin. }.
Number asec := { (/ (self)) acos. }.
Number acot := { (/ (self)) atan. }.

Number asinh := { meta sys numTrig#: self, 10. }.
Number acosh := { meta sys numTrig#: self, 11. }.
Number atanh := { meta sys numTrig#: self, 12. }.
Number acsch := { (/ (self)) asinh. }.
Number asech := { (/ (self)) acosh. }.
Number acoth := { (/ (self)) atanh. }.

Number exp := { meta sys numTrig#: self, 6. }.
Number log := { meta sys numTrig#: self, 13. }.

;; Constructing complex numbers
Number rect := { Number ii * ($2) + ($1). }.
Number polar := { Number ii * ($2) exp * ($1). }.

;; Important constants
Number ee := 1 exp.
Number pi := -1 acos.
Number ii := @(0, 1).

; TODO Add in infinity, neg-infinity, and nan as constants and change the printer to print them in that form

;; Numerical Type Checking
Number isBasicInt? := { (meta sys numLevel#: self) <= 0. }.
Number isInteger?  := { (meta sys numLevel#: self) <= 1. }.
Number isRational? := { (meta sys numLevel#: self) <= 2. }.
Number isFloating? := { (meta sys numLevel#: self) == 3. }.
Number isReal? := { (meta sys numLevel#: self) <= 3. }.
Number isComplex? := { (meta sys numLevel#: self) == 4. }.

;; Radixes
String radix := { takes '[rad].
                  (rad < 2) or (rad > 36) ifTrue { ArgError clone tap
                                                       { self message := "Radix out of bounds". } throw. }.
                  convert := { takes '[n].
                               if: (n >= ("0" ord)) and (n <= ("9" ord)),
                                   { n - ("0" ord). },
                                   { if: (n >= ("a" ord)) and (n <= ("z" ord)),
                                         { n - ("a" ord) + 10. },
                                         { if: (n >= ("A" ord)) and (n <= ("Z" ord)),
                                               { n - ("A" ord) + 10. },
                                               { InputError clone tap
                                                     { self message := "Text is not a number". } throw. }. }. }. }.
                  validate := { ($1) >= (rad) ifTrue { InputError clone tap
                                                           { self message := "Text is not a number". } throw. }. }.
                  num := 0.
                  self visit { curr := convert: $1 ord.
                               validate: curr.
                               parent num := (num) * (rad) + (curr). }.
                  num. }.

modifiedRadix := { takes '[str, rad, parm].
                   result := str radix: rad.
                   if: parm == '-,
                       { - (result). },
                       { if: (parm == '+) or (parm == '()),
                             { result. },
                             { ArgError clone tap { self message := "Sign does not make sense". } throw. }. }. }.

meta radix x := { modifiedRadix: $1, 16, $2. }.
meta radix X := { modifiedRadix: $1, 16, $2. }.
meta radix o := { modifiedRadix: $1, 8, $2. }.
meta radix O := { modifiedRadix: $1, 8, $2. }.
meta radix b := { modifiedRadix: $1, 2, $2. }.
meta radix B := { modifiedRadix: $1, 2, $2. }.

;; Return the script
here.
