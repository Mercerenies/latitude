
;; Cloning and metaprogramming basics
meta Object clone := { meta sys doClone#: self. }.
meta Object is := { meta sys instanceOf#: self, $1. }.
meta Object slot := { meta sys accessSlot#: self, $1. }.
meta Object slot= := { meta sys putSlot#: self, $1, (dynamic hold '$2). }.
meta Object hold := { meta sys accessSlot#: self, $1. }.
meta Object get := { self hold me. }.
meta Object has := { meta sys checkSlot#: self, $1. }.
meta Object put := { meta sys putSlot#: self, $1, (dynamic hold '$2). }.
meta Object origin := { meta sys origin#: self, $1. }.
meta Object invoke := { procd := meta Proc clone.
                        procd call := { meta sys invoke#: parent self,
                                                          (parent dynamic hold '$1). }.
                        procd. }.
meta Object invokeSpecial := { procd := meta Proc clone.
                               procd call := { meta sys doWithCallback#: parent self,
                                                                         (parent dynamic hold '$1),
                                                                         (parent dynamic hold '$2). }.
                               procd. }.
meta Object above := { orgn := self origin: $1.
                       (hold 'orgn) parent hold: $1. }.
meta Object tap := { (self invoke: (dynamic hold '$1)) call.
                     self. }.
meta Object hierarchy := { arr := meta Array clone. ; DO NOT call this on Method or any self-evaluating objects
                           curr := self.
                           while: { (arr detect: { ($1) === (curr). }) not. },
                                  { arr pushBack: curr.
                                    parent curr := curr parent. }.
                           arr. }.

;; Move all of the meta values to the global scope
global Object := meta Object.
global Proc := meta Proc.
global Method := meta hold 'Method.
global Number := meta Number.
global String := meta String.
global Symbol := meta Symbol.
global Stream := meta Stream.
global Process := meta Process.
global SystemCall := meta SystemCall.
global True := meta True.
global False := meta False.
global Nil := meta Nil.
global Boolean := meta Boolean.
global Cont := meta Cont.
global Exception := meta Exception.
global SystemError := meta SystemError.
global Array := meta Array.
global Kernel := meta Kernel.

;; The $whereAmI variable
global $whereAmI := Nil.

;; Basics of exception handling
(hold 'Method) handle := { meta sys try#: { parent self. },
                                          { (parent dynamic $1: $1) toBool. },
                                          { parent dynamic $2. }. }.
(hold 'Method) catch := { (parent hold 'self) handle: { $1 is: parent dynamic $1. },
                                                      { parent dynamic $2. }. }.
Object throw := { meta sys throw#: self. }.
Exception throw := { self stack := dynamic parent.
                     (self invoke: (Object hold 'throw)) call. }.
(hold 'Method) protect := { meta sys scopeProtect#: { parent self. },
                                                    { parent dynamic $1. }. }.

;; Procs and Methods handling
(hold 'Method) closure := global.
Proc call := (hold 'Method) clone.
(hold 'Method) call := { self. }.
(hold 'Method) toString := "Method".
Proc toString := "Proc".
(hold 'Method) < := { (self) < ($1). }. ; Evaluate the method and then try again
Proc <| := { proc { r := (parent dynamic hold '$1) call.
                    (parent hold 'self) call: r. }. }.
Proc |> := { (dynamic hold '$1) <| (hold 'self). }.
Symbol toProc := { sym := self.
                   proc { obj := ArgList clone fill shift.
                          (obj invoke (obj hold: sym)) call. }. }.

;; Cached Procedures
global Cached := Object clone.
Cached toString := "Cached".
Cached value := Nil.
Cached done? := False.
Cached procedure := {}.
Cached call := { if: self done?,
                     { parent self value. },
                     { parent self done? := True.
                       parent self value := parent self procedure call. }. }.

global proc := { curr := self Proc clone.
                 ;curr call := dynamic hold '$1.
                 curr. }.
global memo := { curr := self Cached clone.
                 curr procedure := self proc: (dynamic hold '$1).
                 curr. }.
meta sigil l := { cache := memo: (dynamic hold '$1).
                  { cache call. }. }.
global id := proc { $1. }.

;; Stream general methods
Stream in? := { meta sys streamIn#: self. }.
Stream out? := { meta sys streamOut#: self. }.
Stream puts := { meta sys streamPuts#: self, $1. }.
Stream putln := { meta sys streamPutln#: self, $1. }.
Stream print := { self puts: $1 toString. }.
Stream println := { self putln: $1 toString. }.
Stream dump := { meta sys streamDump#: self, $1. }.
Stream readln := { meta sys streamRead#: self. }.
Stream read := { meta sys streamReadChar#: self. }.
Stream eof? := { meta sys streamEof#: self. }.
Stream close := { meta sys streamClose#: self. }.
Stream open := { meta sys streamFileOpen#: self, $1, $2, $3. }.
Stream closeAfter := { stream := self.
                       { (stream invoke: (parent dynamic hold '$1)) call. } protect { stream close. }. }.
Stream toString := "Stream".

;; Process basics
Process toString := "Process".
Process stdin := { meta sys processInStream#: self. }.
Process stdout := { meta sys processOutStream#: self. }.
Process stderr := { meta sys processErrStream#: self. }.
Process spawn := { meta sys processCreate#: self, $1. }.
Process finished? := { meta sys processFinished#: self. }.
Process running? := { meta sys processRunning#: self. }.
Process exitCode := { meta sys processExitCode#: self. }.
Process execute := { meta sys processExec#: self. }.

;; Scope self-reference
global scope := { self. }.
global $scope := { self. }.
global lexical := global.
global dynamic := global.
global $lexical := global.
global $dynamic := global.
Object me := { self. }.
global here := { if: (self has 'again),
                     { parent self hold 'again. },
                     { meta Nil. }. }.
Object missing := { err := meta SlotError clone.
                    err slotName := dynamic hold '$1.
                    err objectInstance := lexical hold 'self.
                    err throw. }.

;; Equality and Comparability
Object === := { meta sys ptrEquals#: self, $1. }.
Object == := { (self) === ($1). }.
Object > := { ($1) < (self). }.
Object >= := { ((self) > ($1)) or ((self) == ($1)). }.
Object <= := { ((self) < ($1)) or ((self) == ($1)). }.
Object /= := { ((self) == ($1)) not. }.
Object min := { if: ((self) < ($1)), self, $1. }.
Object max := { if: ((self) > ($1)), self, $1. }.

;; Kernel functions
Kernel toString := "Kernel".
; (The load function is defined in the main latitude.lat file)

;; Symbol functions
Symbol gensym := { meta sys gensym#: self clone. }.
Symbol gensymOf := { meta sys gensymOf#: self clone, $1. }.
Symbol asText := { meta sys symbolic#: self. }.
Symbol toString := { meta sys symToString#: self. }.
Symbol pretty := { self asText. }.
Symbol == := { meta sys primEquals#: self, $1. }.
Symbol < := { meta sys primLT#: self, $1. }.
String intern := { meta sys intern#: self. }.
Number ordinal := { meta sys natSym#: self. }.

;; Strings and stringification
Object stringify := { self toString. }.
String stringify := { self. }.
Object ++ := { meta sys stringConcat#: self stringify, $1 stringify. }.
Object toString := "Object".
Object pretty := { (hold 'self) toString. }.
String toString := { meta sys strToString#: self. }.
String pretty := { self. }.
String == := { meta sys primEquals#: self, $1. }.
String < := { meta sys primLT#: self, $1. }.

; Locality information
global $currentLine := { self get: meta lineStorage. }.
global $currentFile := { self get: meta fileStorage. }.
global stackTrace := { meta sys stackDump#: self. }.
global printStackTrace := { stderr putln: self stackTrace. }.

;; We would return the script here, but the `has` function requires flow_control.lat
1.