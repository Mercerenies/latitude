
;; Latitude???

;; Cloning and metaprogramming basics
meta Object clone := { meta sys doClone#: self. }.
meta Object is := { meta sys instanceOf#: self, $1. }.
meta Object slot := { meta sys accessSlot#: self, $1. }.
meta Object hold := { meta sys accessSlot#: self, $1. }.
meta Object get := { self hold me. }.
meta Object has := { meta sys checkSlot#: self, $1. }.
meta Object put := { meta sys putSlot#: self, $1, (dynamic hold '$2). }.
meta Object origin := { meta sys origin#: self, $1. }.
meta Object invoke := { procd := meta Proc clone.
                        procd call := { meta sys invoke#: lexical,
                                                          dynamic,
                                                          parent self,
                                                          (parent dynamic hold '$1). }
                        procd. }.
;; TODO "above" function which acts like super()

;; Move all of the meta values to the global scope
global Object := meta Object.
global Proc := meta Proc.
global Method := meta hold 'Method.
global Number := meta Number.
global String := meta String.
global Symbol := meta Symbol.
global Stream := meta Stream.
global SystemCall := meta SystemCall.
global True := meta True.
global False := meta False.
global Nil := meta Nil.
global Boolean := meta Boolean.
global Cont := meta Cont.
global Exception := meta Exception.
global SystemError := meta SystemError.
global Array := meta Array.
global Kernel := meta Kernel.

;; Basics of exception handling
(hold 'Method) handle := { meta sys try#: lexical,
                                          dynamic,
                                          { parent self. },
                                          { (parent dynamic $1: $1) toBool. },
                                          { parent dynamic $2. }. }.
(hold 'Method) catch := { (parent hold 'self) handle: { $1 is: parent dynamic $1. },
                                                      { parent dynamic $2. }. }.
Object throw := { meta sys throw#: self. }.
(hold 'Method) protect := { meta sys scopeProtect#: lexical,
                                                    dynamic,
                                                    { parent self. },
                                                    { parent dynamic $1. }. }.

;; Exceptions
Exception message := "Exception!".
Exception toString := "Exception".
Exception pretty := { self message. }.

;; Procs and Methods handling
(hold 'Method) closure := global.
Proc call := (hold 'Method) clone.
(hold 'Method) call := { self. }.
global proc := { curr := self Proc clone.
                 curr call := { parent dynamic $1. }.
                 curr. }.
(hold 'Method) toString := "Method".
Proc toString := "Proc".
(hold 'Method) < := { (self) < ($1). }. ; Evaluate the method and then try again

;; Stream general methods
Stream in? := { meta sys streamIn#: self. }.
Stream out? := { meta sys streamOut#: self. }.
Stream puts := { meta sys streamPuts#: self, $1. }.
Stream putln := { meta sys streamPutln#: self, $1. }.
Stream print := { self puts: $1 toString. }.
Stream println := { self putln: $1 toString. }.
Stream dump := { meta sys streamDump: lexical, dynamic, self, $1. }.
Stream readln := { meta sys streamRead#: self. }.
Stream toString := "Stream".

;; Scope self-reference
global scope := { self. }.
global $scope := { self. }.
Object me := { self. }.
global here := { if: (has 'again), { parent hold 'again. }, { meta Nil. }. }.

;; Booleans
Object toBool := True.
False toBool := False.
Nil toBool := False.
Boolean toString := "Boolean".
True toString := "True".
False toString := "False".
Nil toString := "Nil".
global if := { meta sys ifThenElse#: lexical,
                                     dynamic,
                                     $1 toBool,
                                     { parent dynamic $2. },
                                     { parent dynamic $3. }. }.
Object ifTrue := { if: self, { parent dynamic $1. }, { meta Nil. }. }.
Object ifFalse := { if: self, { meta Nil. }, { parent dynamic $1. }. }.
Object and := { if: self, { parent dynamic $1. }, {meta False. }. }.
Object or := { fst := self.
               if: fst, { fst. }, { parent dynamic $1. }. }.
Object not := { if: self, { meta False. }, { meta True. }. }.

;; Loops
global loop := { meta sys loop#: lexical,
                                 dynamic,
                                 { parent dynamic $1. }. }.
global while := { cond := { parent dynamic $1. }.
                  stmt := { parent dynamic $2. }.
                  callCC { $break := { parent dynamic $1 call. }.
                           loop { if: cond,
                                      { stmt. },
                                      { $break: meta Nil. }. }. }. }.

;; Equality and Comparability
Object === := { meta sys ptrEquals#: self, $1. }.
Object == := { (self) === ($1). }.
Object > := { ($1) < (self). }.
Object >= := { ((self) > ($1)) or ((self) == ($1)). }.
Object <= := { ((self) < ($1)) or ((self) == ($1)). }.
Object /= := { ((self) == ($1)) not. }.

;; Kernel functions
Kernel toString := "Kernel".
Kernel load := { meta sys loadFile#: lexical, dynamic, global, $1. }.

;; Symbol functions
Symbol gensym := { meta sys gensym#: self. }.
Symbol gensymOf := { meta sys gensymOf#: self, $1. }.
Symbol asText := { meta sys symbolic#: lexical, self. }.
Symbol toString := { meta sys primToString#: self. }.
Symbol pretty := { self asText. }.
Symbol == := { meta sys primEquals#: self, $1. }.
Symbol < := { meta sys primLT#: self, $1. }.
String intern := { meta sys intern#: lexical, self. }.
Number ordinal := { meta sys natSym#: self. }.

;; Strings and stringification
Object stringify := { self toString. }.
String stringify := { self. }.
Object ++ := { meta sys stringConcat#: self stringify, $1 stringify. }.
Object toString := "Object".
Object pretty := { (hold 'self) toString. }.
String toString := { meta sys primToString#: self. }.
String pretty := { self. }.
String == := { meta sys primEquals#: self, $1. }.
String < := { meta sys primLT#: self, $1. }.

;; Arithmetic and Number Types
Number toString := { meta sys primToString#: self. }.
Number == := { meta sys primEquals#: self, $1. }.
Number < := { meta sys primLT#: self, $1. }.
Number + := { meta sys numAdd#: self, $1. }.
Number - := { meta sys numSub#: self, $1. }.
Number * := { meta sys numMul#: self, $1. }.
Number / := { meta sys numDiv#: self, $1. }.
Number mod := { meta sys numMod#: self, $1. }.

;; Numerical Type Checking
Number isBasicInt? := { (meta sys numLevel#: self) <= 0. }.
Number isInteger?  := { (meta sys numLevel#: self) <= 1. }.
Number isRational? := { (meta sys numLevel#: self) <= 2. }.
Number isFloating? := { (meta sys numLevel#: self) == 3. }.

;; Array functions
Array lowerBound := 0.
Array upperBound := 0.
Array mapping := { var := $1.
                   if: { var >= 0. },
                       { (var * 2) + 1. },
                       { var * -2. }. }.
Array empty? := { (self lowerBound) >= (self upperBound). }.
Array pushFront := { value := $1.
                     self lowerBound := self lowerBound - 1.
                     self put: (self mapping: self lowerBound) ordinal, value.
                     value. }.
Array pushBack := { value := $1.
                    self put: (self mapping: self upperBound) ordinal, value.
                    self upperBound := self upperBound + 1.
                    value. }.
Array popFront := { if: self empty?,
                        { meta BoundsError clone throw. },
                        { self := parent self.
                          self lowerBound := self lowerBound + 1.
                          self get: (self mapping: (self lowerBound - 1)) ordinal. }. }.
Array popBack := { if: self empty?,
                       { meta BoundsError clone throw. },
                       { self := parent self.
                         self upperBound := self upperBound - 1.
                         self get: (self mapping: self upperBound) ordinal. }. }.
Array nth := { pos := if: ($1 < 0),
                          { (parent self upperBound) + (parent dynamic $1). },
                          { (parent self lowerBound) + (parent dynamic $1). }.
               if: ((pos < (self lowerBound)) or (pos >= (self upperBound))),
                   { meta BoundsError clone throw. },
                   { self := parent self.
                     self get: (self mapping: pos) ordinal. }. }.
Array nth= := { pos := if: ($1 < 0),
                           { (parent self upperBound) + (parent dynamic $1). },
                           { (parent self lowerBound) + (parent dynamic $1). }.
                if: ((pos < (self lowerBound)) or (pos >= (self upperBound))),
                    { meta BoundsError clone throw. },
                    { self := parent self.
                      self put: (self mapping: pos) ordinal, parent dynamic $2. }. }.
Array size := { (self upperBound) - (self lowerBound). }.
Array join := { index := 1.
                size := self size.
                delim := { parent dynamic $1. }.
                str := if: self empty?,
                           { "". },
                           { (parent self nth: 0) toString. }.
                while: { (index) < (size). },
                       { parent str := (str) ++ ((delim) ++ ((parent self nth: index) toString)).
                         parent index := index + 1. }.
                str. }.
Array toString := { "[" ++ ((self join ", ") ++ "]"). }. ; TODO Make the infix syntax friendlier
; TODO Equality and comparability

;; Array Syntax
meta brackets := { ArrayBuilder := self Object clone.
                   ArrayBuilder toString := "ArrayBuilder".
                   ArrayBuilder array := self Array clone.
                   ArrayBuilder next := { self array pushBack: $1. }.
                   ArrayBuilder finish := { self array. }.
                   ArrayBuilder. }.

;; Continuations
Cont tag := Nil.
Cont call := { meta sys exitCC#: lexical, dynamic, self tag, $1. }.
global callCC := { meta sys callCC#: lexical, dynamic, { parent dynamic $1. }. }.

;; "Cells" a la MIT Scheme
global Cell := Object clone.
Cell value := Nil.
Cell toString := "Cell".

;; Lockboxes and Latchkeys
global Latchkey := Object clone.
global Lockbox := Object clone.
Latchkey tag := Symbol.
Latchkey make := { key := self clone.
                   key tag := key tag gensymOf: "KEY".
                   key. }.
Lockbox store := { self put: $1 tag, $2. }.
Lockbox fits := { self has: $1 tag. }.
Lockbox retrieve := { if: { parent self fits: parent dynamic $1. },
                          { parent self get: parent dynamic $1 tag. },
                          { meta Nil. }. }.
Lockbox toString := "Lockbox".
Latchkey toString := "Latchkey".
Latchkey pretty := { "Key " ++ (self tag pretty). }.
Latchkey == := { (self tag) == (self tag). }.
