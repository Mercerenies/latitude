;;* MODULE sequence
;;* PACKAGE base

sequence := $whereAmI.

SequenceIterator ::= Iterator clone.
SequenceIterator inside := Nil.
SequenceIterator next := { self inside := self inside cdr. }.
SequenceIterator end? := { self inside nil?. }.
SequenceIterator element := { self inside car. }.
SequenceIterator element= := { self inside car := $1. }.
sequence SequenceIterator := SequenceIterator.

;; Forward linked lists
Sequence := Object clone.
Sequence toString := { "#<Sequence " ++ (self list pretty) ++ ">". }.
Sequence list := Nil.
Sequence fromArray := {
  arr := $1.
  self clone tap {
    self list := arr foldr (Nil, { cons (#'$1, $2). }).
  }.
}.
Sequence iterator := {
  iter := SequenceIterator clone.
  iter inside := self list.
  iter.
}.
Sequence head := {
  if (self list nil?)
    then { Nil. }
    else { parent self list car. }.
}.
Sequence tail := {
  seq := self clone.
  if (self list nil?)
    then { seq list := Nil. }
    else { seq list := parent self list cdr. }.
  seq.
}.
Sequence lazy := {
  cons0 := self list.
  seq := LazySequence clone.
  lazyCons := { cons1 := $1.
                cache := memo { lazyCons: cons1 cdr. }.
                if ($1 nil?)
                  then { Nil. }
                  else { cc := Cons clone.
                         cc car := cons1 car.
                         cc cdr := { cache call. }. ; ///// Rework the lazy sequences so that this is implemented in terms of Proc iterate and so that cons cells are mutable *wherever possible*
                         cc. }. }.
  seq list := lazyCons: cons0.
  seq.
}.
sequence Sequence := Sequence.

Collection inject: Sequence.

;; A lazy sequence implementation, designed to allow infinite data structures. To
;; allow these to work, it is necessary to manually override several Collection
;; functions.
LazySequence := Sequence clone.
LazySequence toString := {
  if (self list nil?)
    then { "#<LazySequence ()>". }
    else { "#<LazySequence (" ++ (parent self list car) ++ " ...)>". }.
}.
LazySequence list := Nil.
LazySequence map! := {
  func0 := #'$1.
  func := {
    #'func0 call.
  }.
  recurse := {
    curr := $1.
    if (curr nil?)
      then { Nil. }
      else {
        cell := Cons clone.
        cell car := { func: curr car. }.
        cell cdr := { recurse: curr cdr. }.
      }.
  }.
  self list := recurse: self list.
}.
LazySequence visit := {
  func0 := #'$1.
  func := {
    #'func0 call.
  }.
  recurse := {
    curr := $1.
    if (curr nil?)
      then { Nil. }
      else {
        cell := Cons clone.
        cell car := func: curr car.
        cell cdr := recurse: curr cdr.
      }.
  }.
  recurse: self list.
}.
LazySequence foldr := {
  func0 := #'$2.
  func := {
    #'func0 call.
  }.
  init := #'$1.
  recurse := {
    curr := $1.
    cache := memo { recurse: curr cdr. }.
    if (curr nil?)
      then { init. }
      else {
        func: curr car, { cache call. }.
      }.
  }.
  recurse: self list.
}.
LazySequence make := {
  func := #'$1.
  seq := self clone.
  recurse := {
    curr := Cons clone.
    curr car := ~l { func. }.
    curr car= := {
      self car.
      self car := #'$1.
    }.
    curr cdr := ~l {
      curr car.
      recurse.
    }.
    curr cdr= := {
      err ReadOnlyError clone tap {
        self message := "Read-only cell".
      } throw.
    }.
    curr.
  }.
  seq list := recurse.
  seq.
}.
sequence LazySequence := LazySequence.

Proc iterate := {
  procd := proc { (parent slot 'self) call. }.
  recurse := {
    curr := $1.
    cell := Cons clone.
    cell car := ~l { curr. }.
    cell cdr := ~l { recurse: procd call (curr). }.
    cell.
  }.
  seq := LazySequence clone.
  seq list := recurse: $1.
  seq.
}.

;; Return the script
$whereAmI.