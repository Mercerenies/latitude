
;; In case Array is changed later, we still want toArray to return the original idea of an "array"
Array := Array.
True := True.
False := False.
Nil := Nil.

;; Collection implementations are expected to have `iterator`, as well as a sane `clone`.
;; Implementors are encourages to override these methods where appropriate to make them more efficient,
;; for example the `size` method.
global Collection := Mixin clone.
Collection toString := "Collection".
Collection interface := '[map!, visit, map, foldl, foldr, size, toArray, all, any, notall, notany,
                          detect, countIf, count, find, containsIf, contains, zip, zip!].
Collection map! := { func := { (parent dynamic hold '$1) call. }.
                     iter := self iterator.
                     while: { iter end? not. },
                            { iter element=: (func: iter element).
                              iter next. }.
                     self. }.
Collection visit := { self map!: { (parent dynamic hold '$1) call.
                                   $1. }. }.
Collection map := { coll := self clone.
                    coll map!: { (parent dynamic hold '$1) call. }. }.
Collection foldl := { accum := $1.
                      self visit: { parent accum := (parent dynamic hold '$2) call: accum, $1. }.
                      accum. }.
Collection foldr := { func := proc { (parent dynamic hold '$2) call. }.
                      accum := proc { $1. }. ; TODO Name the identity function in the global scope
                      self visit: { parent accum := accum <| (proc { func call: parent dynamic $1, $1. }). }.
                      accum call: $1. }.
Collection size := { self foldl: 0, { $1 + 1. }. }.
Collection toArray := { arr := Array clone.
                        self visit: { arr pushBack. }.
                        arr. }.
Collection all := { func := proc { (parent dynamic hold '$1) call. }.
                    callCC { return := { parent dynamic $1 call. }.
                             parent self visit: { arg := $1.
                                                  (func call: arg) ifFalse: { return: False. }. }.
                             True. }. }.
Collection any := { func := proc { (parent dynamic hold '$1) call. }.
                    callCC { return := { parent dynamic $1 call. }.
                             parent self visit: { arg := $1.
                                                  (func call: arg) ifTrue: { return: arg. }. }.
                             False. }. }.
Collection notAll := { func := proc { (parent dynamic hold '$1) call. }.
                       callCC { return := { parent dynamic $1 call. }.
                                parent self visit: { arg := $1.
                                                     (func call: arg) ifFalse: { return: True. }. }.
                                False. }. }.
Collection notAny := { func := proc { (parent dynamic hold '$1) call. }.
                       callCC { return := { parent dynamic $1 call. }.
                                parent self visit: { arg := $1.
                                                     (func call: arg) ifTrue: { return: False. }. }.
                                True. }. }.
Collection detect := { func := proc { (parent dynamic hold '$1) call. }.
                       callCC { return := { parent dynamic $1 call. }.
                                parent self visit: { arg := $1.
                                                     (func call: arg) ifTrue: { return: arg. }. }.
                                Nil. }. }.
Collection countIf := { func := proc { (parent dynamic hold '$1) call. }.
                        self foldl: 0, { if: (func call: $2),
                                             ($1 + 1),
                                             $1. }. }.
Collection count := { self countIf: { (parent dynamic $1) == ($1). }. }.
Collection find := { self detect: { (parent dynamic $1) == ($1). }. }.
Collection containsIf := { func := proc { (parent dynamic hold '$1) call. }.
                           callCC { return := { parent dynamic $1 call. }.
                                    parent self visit: { arg := $1.
                                                         (func call: arg) ifTrue: { return: True. }. }.
                                    False. }. }.
Collection contains := { self containsIf: { (parent dynamic $1) == ($1). }. }.
; Note that `zip` returns an array and will be of the shorter length of the two. It should not be used
;  unless at least one of the arguments is finite in length.
; On the other hand, `zip!` modifies the `self` argument. If the argument is shorter than `self`, it will be
;  padded with Nil. As such, `zip!` is safe to use on infinite structures.
Collection zip := { iter0 := self iterator.
                    iter1 := $1 iterator.
                    arr := Array clone.
                    while: { (iter0 end? not) and (iter1 end? not). },
                           { arr pushBack: [iter0 element, iter1 element].
                             iter0 next.
                             iter1 next. }.
                    arr. }.
Collection zip! := { iter1 := $1 iterator.
                     self map!: { curr := $1.
                                  if: iter1 end?,
                                      { [curr, Nil]. },
                                      { [curr, iter1 element] tap { iter1 next. }. }. }. }.
; TODO maximum and minimum (need to handle the corner cases well)
; TODO filter (probably needs to be done in the individual components, not in terms of visit / map)

Collection inject: Array.

;; Return the script
here.