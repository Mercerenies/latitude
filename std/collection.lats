
global Iterator ::= Object clone.
Iterator iterator := { self clone. }.
Iterator end? := True.
Iterator next := { }.
Iterator element := Nil.
Iterator element= := {
  err ReadOnlyError clone tap { self message := "Immutable iterator". } throw.
}.

;; Collection implementations are expected to have `iterator`, as well as a sane `clone`.
;; Implementors are encourages to override these methods where appropriate to make them more efficient,
;; for example the `size` method. The iterator returned by `iterator` must support the following:
;; *  `end?` - A 0-ary method which returns whether the iterator is at the end
;; *  `next` - Moves the iterator to the next value; if at the last value, the iterator is moved to a special
;;             "end" position for which `end?` returns true and `element` is invalid
;; *  `element` - Returns the current value to which the iterator points; this value need only be
;;                well-defined when `end?` is false
;; *  `element=` - Sets the current element; if the iterator is read-only, `element=` should be defined
;;                 to throw a `ReadOnlyError` with an appropriate message; as with `element`, this need
;;                 only be well-defined when `end?` is false
;; *  `clone` - Iterators must be cloneable at any intermediate point in their iteration
;; () `toString` - Although not strictly required, it is recommended that this exist for convenience
global Collection ::= Mixin clone.
Collection interface := '[map!, visit, map, foldl, foldr, size, length, toArray, all, any,
                          notall, notany, detect, countIf, count, find, containsIf, contains,
                          zip, zip!, take, drop, maximum, minimum, <>, sum, product, append,
                          empty?].
Collection map! := {
  func0 := #'$1.
  func := { #'func0 call. }.
  iter := self iterator.
  while { iter end? not. }
    do {
      iter element=: (func: iter element).
      iter next.
    }.
  self.
}.
Collection visit := {
  func0 := #'$1.
  func := { #'func0 call. }.
  iter := self iterator.
  while { iter end? not. }
    do {
      func: iter element.
      iter next.
    }.
  self.
}.
Collection map := {
  coll := self clone.
  func0 := #'$1.
  func := { #'func0 call. }.
  coll map! {
    func.
  }.
}.
Collection foldl := {
  func0 := #'$2.
  func := { #'func0 call. }.
  accum := $1.
  self visit {
    parent accum := func (accum, #'$1).
  }.
  accum.
}.
Collection foldr := {
  func0 := #'$2.
  func := proc { #'func0 call. }.
  arg := #'$1.
  iter := self iterator.
  rec := {
    ~l {
      if (iter end?) then {
        #'arg.
      } else {
        elem := iter element.
        iter next.
        func call: elem, rec.
      }.
    }.
  }.
  rec me.
}.
Collection size := { self foldl: 0, { $1 + 1. }. }.
Collection length := { self size. }.
Collection toArray := {
  arr := Array clone.
  self visit: { arr pushBack. }.
  arr.
}.
Collection all := {
  func0 := #'$1.
  func := proc { #'func0 call. }.
  coll := #'self.
  callCC {
    escapable.
    coll visit {
      curr := #'$1.
      value := func call (#'curr).
      #'value ifFalse { return #'value. }.
    }.
    True.
  }.
}.
Collection any := {
  func0 := #'$1.
  func := proc { #'func0 call. }.
  callCC {
    escapable.
    parent self visit {
      curr := #'$1.
      value := func call (#'curr).
      #'value ifTrue { return #'value. }.
    }.
    False.
  }.
}.
Collection notAll := {
  func0 := #'$1.
  func := proc { #'func0 call. }.
  callCC {
    escapable.
    parent self visit {
      (func call #'$1) ifFalse: { return: True. }.
    }.
    False.
  }.
}.
Collection notAny := {
  func0 := #'$1.
  func := proc { #'func0 call. }.
  callCC {
    escapable.
    parent self visit {
      (func call #'$1) ifTrue: { return: False. }.
    }.
    True.
  }.
}.
Collection detect := {
  func0 := #'$1.
  func := proc { #'func0 call. }.
  callCC {
    escapable.
    parent self visit {
      curr := #'$1.
      func call (#'curr) ifTrue { return #'curr. }.
    }.
    Nil.
  }.
}.
Collection countIf := {
  func0 := #'$1.
  func := proc { #'func0 call. }.
  self foldl: 0, {
    if (func call #'$2)
      then (#'$1 + 1)
      else (#'$1).
  }.
}.
Collection count := {
  arg := #'$1.
  self countIf: { #'arg == #'$1. }.
}.
Collection find := {
  arg := #'$1.
  self detect: { #'arg == #'$1. }.
}.
Collection containsIf := {
  func0 := #'$1.
  func := proc { #'func0 call. }.
  callCC {
    escapable.
    parent self visit {
      arg := #'$1.
      (func call #'arg) ifTrue: { return: True. }.
    }.
    False.
  }.
}.
Collection contains := {
  arg := #'$1.
  self containsIf { #'arg == #'$1. }.
}.
; Note that `zip` returns an array and will be of the shorter length of the two. It should not be used
;  unless at least one of the arguments is finite in length.
; On the other hand, `zip!` modifies the `self` argument. If the argument is shorter than `self`, it will be
;  padded with Nil. As such, `zip!` is safe to use on infinite structures.
Collection zip := {
  iter0 := self iterator.
  iter1 := $1 iterator.
  arr := Array clone.
  while { (iter0 end? not) and (iter1 end? not). }
    do {
      arr pushBack: (cons: iter0 element, iter1 element).
      iter0 next.
      iter1 next.
    }.
  arr.
}.
Collection zip! := {
  iter1 := $1 iterator.
  self map! {
    curr := $1.
    if (iter1 end?)
      then { cons: curr, Nil. }
      else {
        (cons: curr, iter1 element) tap {
          iter1 next.
        }.
      }.
  }.
}.
Collection take := {
  remaining := $1.
  decrement := {
    parent remaining := remaining - 1.
  }.
  arr := Array clone.
  callCC {
    escapable.
    parent self visit {
      curr := #'$1.
      if (remaining > 0)
        then {
          arr pushBack: #'curr.
          decrement.
        } else {
          return: Nil.
        }.
    }.
  }.
  arr.
}.
Collection drop := {
  remaining := $1.
  decrement := {
    parent remaining := remaining - 1.
  }.
  callCC {
    escapable.
    iter := parent self iterator.
    while { iter end? not. } do {
      if (remaining > 0)
        then {
          decrement.
        } else {
          return: iter.
        }.
      iter next.
    }.
    Nil.
  }.
}.
Collection maximum := {
  current := Nil.
  isSet := False.
  setCurrent := {
    parent isSet := True.
    parent current := #'$1.
  }.
  maximize := {
    takes '[value].
    isSet ifFalse {
      setCurrent #'value.
    }.
    (#'value > #'current) ifTrue {
      setCurrent #'value.
    }.
  }.
  self visit { maximize #'$1. }.
  current.
}.
Collection minimum := {
  current := Nil.
  isSet := False.
  setCurrent := {
    parent isSet := True.
    parent current := #'$1.
  }.
  minimize := {
    takes '[value].
    isSet ifFalse {
      setCurrent #'value.
    }.
    (#'value < #'current) ifTrue {
      setCurrent #'value.
    }.
  }.
  self visit { minimize #'$1. }.
  current.
}.

global Chain ::= Object clone.
Chain first := Nil.
Chain second := Nil.
Chain iterator := {
  ChainIterator make: self first, self second.
}.

global ChainIterator ::= Iterator clone.
ChainIterator nilThing := Nil.
ChainIterator iter := Nil.
ChainIterator secondHalf := Nil.
ChainIterator element := { self iter element. }.
ChainIterator element= := { self iter element=. }.
ChainIterator next := {
  localize.
  hasSecondHalf := this secondHalf is (this nilThing) not.
  this iter next.
  (this iter end?) and (hasSecondHalf) ifTrue {
    this iter := this secondHalf iterator.
    this secondHalf := this nilThing.
  }.
}.
ChainIterator end? := { self iter end?. }.
ChainIterator make := {
  first := #'$1.
  second := #'$2.
  self clone tap {
    ; We must construct a "NilThing" to act like
    ; Nil since Nil is a valid element in a chain
    localize.
    this nilThing := Nil clone.
    this iter := #'first iterator.
    this secondHalf := #'second.
    this end? ifTrue {
      this iter := this secondHalf iterator.
      this secondHalf := this nilThing.
    }.
  }.
}.

Collection <> := {
  chain := Chain clone.
  chain first := self.
  chain second := $1.
  chain.
}.

;; Utility functions
Collection sum := { self foldl: 0, '+ toProc. }.
Collection product := { self foldl: 1, '* toProc. }.
Collection append := { self foldl: "", '++ toProc. }.
Collection empty? := { self iterator end?. }.

;; Collection Methods for Array
global ArrayIterator ::= Iterator clone.
ArrayIterator index := 0.
ArrayIterator array := Nil.
ArrayIterator next := { self index := self index + 1. }.
ArrayIterator end? := { self index >= self array size. }.
ArrayIterator element := { self array nth (self index). }.
ArrayIterator element= := { self array nth (self index) = #'$1. }.
Array iterator := {
  ArrayIterator clone tap {
    self index := 0.
    self array := parent self.
  }.
}.

;; Nil is an iterator over an empty collection
Nil iterator := {
  NilIterator ::= Iterator clone.
  NilIterator end? := True.
  NilIterator.
}.
Collection inject: Nil.

DictIterator ::= Object clone.
DictIterator keys := Nil iterator.
DictIterator dict := Nil.
DictIterator end? := { self keys end?. }.
DictIterator next := { self keys next. }.
DictIterator element := {
  key := self keys element.
  cons (key, self dict get (key)).
}.
Dict iterator := {
  iter := DictIterator clone.
  iter dict := self.
  iter keys := Kernel keys (self &impl).
  iter keys upperBound := iter keys upperBound - 2. ; My insides are screaming at this hack
  self has? 'missing ifTrue {
    iter keys pushBack 'missing.
  }.
  self has? 'parent ifTrue {
    iter keys pushBack 'parent.
  }.
  iter keys := iter keys iterator.
  iter.
}.
Dict keys := {
  self iterator keys.
}.
Dict values := {
  localize.
  this iterator keys map {
    this get.
  }.
}.

;; Immutable iterator; needs map override
Dict map := {
  func0 := #'$1.
  func := { #'func0 call. }.
  coll := Dict clone.
  self visit {
    res := func ($1).
    coll get (res car) = res cdr.
  }.
  coll.
}.

Collection inject: Array.
Collection inject: Dict.
Collection inject: Chain.

Collection inject: Iterator.

;; Return the script
here.