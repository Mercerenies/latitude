
;; Collection implementations are expected to have `iterator`, as well as a sane `clone`.
;; Implementors are encourages to override these methods where appropriate to make them more efficient,
;; for example the `size` method. The iterator returned by `iterator` must support the following:
;; *  `end?` - A 0-ary method which returns whether the iterator is at the end
;; *  `next` - Moves the iterator to the next value; if at the last value, the iterator is moved to a special
;;             "end" position for which `end?` returns true and `element` is invalid
;; *  `element` - Returns the current value to which the iterator points; this value need only be
;;                well-defined when `end?` is false
;; *  `element=` - Sets the current element; if the iterator is read-only, `element=` should be defined
;;                 to throw a `ReadOnlyError` with an appropriate message; as with `element`, this need
;;                 only be well-defined when `end?` is false
;; *  `clone` - Iterators must be cloneable at any intermediate point in their iteration
;; () `toString` - Although not strictly required, it is recommended that this exist for convenience
global Collection ::= Mixin clone.
Collection interface := '[map!, visit, map, foldl, foldr, size, length, toArray, all, any, notall, notany,
                          detect, countIf, count, find, containsIf, contains, zip, zip!, take, maximum,
                          minimum, <>, sum, product, append].
Collection map! := {
  func := { (parent dynamic slot '$1) call. }.
  iter := self iterator.
  while { iter end? not. }
    do {
      iter element=: (func: iter element).
      iter next.
    }.
  self.
}.
Collection visit := {
  func := { (parent dynamic slot '$1) call. }.
  iter := self iterator.
  while { iter end? not. }
    do {
      func: iter element.
      iter next.
    }.
  self.
}.
Collection map := {
  coll := self clone.
  coll map! {
    (parent dynamic slot '$1) call.
  }.
}.
Collection foldl := {
  accum := $1.
  self visit {
    parent accum := (parent dynamic slot '$2) call: accum, #'$1.
  }.
  accum.
}.
Collection foldr := {
  func := proc { (parent dynamic slot '$2) call. }.
  accum := id.
  self visit {
    parent accum := accum <| (proc {
      func call:
        parent dynamic slot '$1,
        #'$1.
    }).
  }.
  accum call: $1.
}.
Collection size := { self foldl: 0, { $1 + 1. }. }.
Collection length := { self size. }.
Collection toArray := {
  arr := Array clone.
  self visit: { arr pushBack. }.
  arr.
}.
Collection all := {
  func := proc {
    (parent dynamic slot '$1) call.
  }.
  callCC {
    return := { parent dynamic $1 call. }.
    parent self visit {
      (func call #'$1) ifFalse: { return: False. }.
    }.
    True.
  }.
}.
Collection any := {
  func := proc {
    (parent dynamic slot '$1) call.
  }.
  callCC {
    return := { parent dynamic $1 call. }.
    parent self visit {
      (func call: dynamic slot '$1) ifTrue: { return: parent dynamic slot '$1. }.
    }.
    False.
  }.
}.
Collection notAll := {
  func := proc {
    (parent dynamic slot '$1) call.
  }.
  callCC {
    return := { parent dynamic $1 call. }.
    parent self visit {
      (func call #'$1) ifFalse: { return: True. }.
    }.
    False.
  }.
}.
Collection notAny := {
  func := proc {
    (parent dynamic slot '$1) call.
  }.
  callCC {
    return := { parent dynamic $1 call. }.
    parent self visit {
      (func call #'$1) ifTrue: { return: False. }.
    }.
    True.
  }.
}.
Collection detect := {
  func := proc {
    (parent dynamic slot '$1) call.
  }.
  callCC {
    return := { parent dynamic $1 call. }.
    parent self visit {
      (func call #'$1) ifTrue: { return: parent dynamic slot '$1. }.
    }.
    Nil.
  }.
}.
Collection countIf := {
  func := proc {
    (parent dynamic slot '$1) call.
  }.
  self foldl: 0, {
    if (func call #'$2)
      then (#'$1 + 1)
      else (#'$1).
  }.
}.
Collection count := {
  self countIf: { (parent dynamic slot '$1) == #'$1. }.
}.
Collection find := {
  self detect: { (parent dynamic slot '$1) == #'$1. }.
}.
Collection containsIf := {
  func := proc {
    (parent dynamic slot '$1) call.
  }.
  callCC {
    return := { parent dynamic $1 call. }.
    parent self visit {
      arg := #'$1.
      (func call #'arg) ifTrue: { return: True. }.
    }.
    False.
  }.
}.
Collection contains := {
  self containsIf { (parent dynamic slot '$1) == #'$1. }.
}.
; Note that `zip` returns an array and will be of the shorter length of the two. It should not be used
;  unless at least one of the arguments is finite in length.
; On the other hand, `zip!` modifies the `self` argument. If the argument is shorter than `self`, it will be
;  padded with Nil. As such, `zip!` is safe to use on infinite structures.
Collection zip := {
  iter0 := self iterator.
  iter1 := $1 iterator.
  arr := Array clone.
  while { (iter0 end? not) and (iter1 end? not). }
    do {
      arr pushBack: (cons: iter0 element, iter1 element).
      iter0 next.
      iter1 next.
    }.
  arr.
}.
Collection zip! := {
  iter1 := $1 iterator.
  self map! {
    curr := $1.
    if (iter1 end?)
      then { cons: curr, Nil. }
      else {
        (cons: curr, iter1 element) tap {
          iter1 next.
        }.
      }.
  }.
}.
Collection take := {
  remaining := $1.
  decrement := {
    parent remaining := remaining - 1.
  }.
  arr := Array clone.
  callCC {
    return := { parent dynamic $1 call. }.
    parent self visit {
      if (remaining > 0)
        then {
          arr pushBack: parent dynamic $1.
          decrement.
        } else {
          return: Nil.
        }.
    }.
  }.
  arr.
}.
Collection maximum := {
  current := Nil.
  isSet := False.
  setCurrent := {
    parent isSet := True.
    parent current := #'$1.
  }.
  maximize := {
    takes '[value].
    isSet ifFalse {
      setCurrent #'value.
    }.
    (#'value > #'current) ifTrue {
      setCurrent #'value.
    }.
  }.
  self visit { maximize #'$1. }.
  current.
}.
Collection minimum := {
  current := Nil.
  isSet := False.
  setCurrent := {
    parent isSet := True.
    parent current := #'$1.
  }.
  minimize := {
    takes '[value].
    isSet ifFalse {
      setCurrent #'value.
    }.
    (#'value < #'current) ifTrue {
      setCurrent #'value.
    }.
  }.
  self visit { minimize #'$1. }.
  current.
}.
Collection <> := {
  Chain ::= Object clone.
  Chain iterator := {
    ; We must construct a "NilThing" to act like
    ; Nil since Nil is a valid element in a chain
    NilThing ::= Nil clone.
    ChainIterator ::= Object clone.
    ChainIterator iter := parent self iterator.
    ChainIterator secondHalf := parent dynamic $1.
    ChainIterator element := { self iter element. }.
    ChainIterator element= := { self iter element=. }.
    ChainIterator next := {
      localize.
      hasSecondHalf := this secondHalf is (NilThing) not.
      this iter next.
      (this iter end?) and (hasSecondHalf) ifTrue {
        this iter := this secondHalf iterator.
        this secondHalf := NilThing.
      }.
    }.
    ChainIterator end? := { self iter end?. }.
    (ChainIterator end?) ifTrue {
      ChainIterator iter := ChainIterator secondHalf iterator.
      ChainIterator secondHalf := NilThing.
    }.
    ChainIterator.
  }.
  Collection inject: Chain.
  Chain.
}.

;; Utility functions
Collection sum := { self foldl: 0, '+ toProc. }.
Collection product := { self foldl: 1, '* toProc. }.
Collection append := { self foldl: "", '++ toProc. }.

Collection inject: Array.

;; Nil is an iterator over an empty collection
Nil iterator := {
  NilIterator ::= Object clone.
  NilIterator end? := True.
  NilIterator.
}.
Collection inject: Nil.

;; Return the script
here.