;;* MODULE regexp
;;* PACKAGE base

; TODO Redesign the basis here so it can work (probably with `callAmb`, not monads), then finish

; NOTE TO SELF: When you redo this file, change the indentation style to the new format.
;               I would do it now, but I believe the branch regexp is relying on this
;               file.

use 'pattern import '[Match, NoMatch].

RegexpError ::= Exception clone tap { self message := "Regexp Error". }.

Regexp ::= Object clone.
Regexp specialChars := ["\\", "/"].
Regexp escapeText := { $1 map { if (parent self specialChars find ($1))
                                  then { "\\" ++ (parent dynamic $1). }
                                  else #'$1. }. }.
Regexp pattern := { node := Object clone tap { self elem := ReLiteral make "". }.
                    node= := { parent node := $1. }.
                    concatenate := { takes '[arg].
                                     if ((node elem is (ReLiteral)) and (arg is (ReLiteral)))
                                       then { node elem text := (node elem text) ++ (arg text). }
                                       else { node elem = ReConcat make: node elem, arg. }. }.
                    iter := $1 iterator.
                    while { iter end? not. }
                       do { curr := iter element.
                            cond { when (curr == "\\")
                                     do { iter next.
                                          iter end? ifTrue { RegexpError clone tap
                                                                { self message := "Invalid escape". } throw. }.
                                          concatenate: ReLiteral make (iter element). }.
                                   else { concatenate: ReLiteral make (curr). }. }.
                            iter next. }.
                    ((node) === (Object)) or ((node parent) === (Object) not) ifTrue
                        { RegexpError clone tap { self message := "Unclosed element". } throw. }.
                    node elem. }.

ReMatch ::= pattern Match clone.
ReMatch groups := Array.
ReMatch clone := { self invoke (Object slot 'clone) tap { self groups := self groups clone. }. }.

meta lang / := { Regexp pattern: ($1 substring: 0,
                                                $1 size - 1). }.

ReObject := Object clone.
ReObject toString := { "#(/" ++ (self asRegexp) ++ "/)". }.
ReObject pretty := { self asRegexp. }.
ReObject asRegexp := "".
ReObject match := { Array clone. }.

ReConcat := ReObject clone.
ReConcat make := { self clone tap { self lhs := parent dynamic $1.
                                    self rhs := parent dynamic $2. }. }.
ReConcat asRegexp := { (self lhs asRegexp) ++ (self rhs asRegexp). }.
; ///// Match for this and ReLiteral

ReLiteral := ReObject clone.
ReLiteral make := { self clone tap { self text := parent dynamic $1. }. }.
ReLiteral text := "".
ReLiteral asRegexp := { Regexp escapeText: self text. }.