
;; The argument list. When filled, it takes the current dynamic scope and references its argument list.
global ArgList := Object clone.
ArgList toString := "ArgList".
ArgList enclosingScope := global.
ArgList clone := { procd := self invoke: (Object hold 'clone).
                   procd call tap { self enclosingScope := self enclosingScope clone. }. }.
ArgList fill := { self enclosingScope := dynamic parent.
                  self. }.
ArgList fillWith := { self enclosingScope := $1.
                      self. }.
ArgList shift := { if: (self size == 0),
                       { meta Nil. },
                       { self := parent self.
                         first := self enclosingScope hold '$1.
                         arglist := self.
                         size := self size.
                         temp := hold 'first.
                         index := 2.
                         self map!: { if: ((index) > (size)),
                                          { hold 'first. },
                                          { result := arglist enclosingScope hold: ((("$") ++ (index)) intern).
                                            parent parent index := index + 1.
                                            hold 'result. }. }.
                         hold 'first. }. }.
ArgList unshift := { if: (self size == 0),
                         { meta Nil. },
                         { self := parent self.
                           first := self enclosingScope $1.
                           arglist := self.
                           size := self size.
                           temp := meta Nil.
                           self map!: { temp1 := temp.
                                        parent temp := $1.
                                        temp1. }.
                           self enclosingScope $1 := temp. }. }.
ArgList iterator := { ArgIterator := Object clone.
                      ArgIterator array := self.
                      ArgIterator toString := "ArgIterator".
                      ArgIterator index := 1.
                      ArgIterator next := { self index := self index + 1. }.
                      ArgIterator end? := { (self array enclosingScope has: ("$" ++ (self index)) intern) not. }.
                      ArgIterator element := { self array enclosingScope hold: ("$" ++ (self index)) intern. }.
                      ArgIterator element= := { self array enclosingScope put: ("$" ++ (self index)) intern,
                                                                               dynamic hold '$1. }.
                      ArgIterator. }.
ArgList dropIn := { target := dynamic parent.
                    index := 1.
                    self visit { target put: (("$" ++ (index)) intern), $1.
                                 parent index := index + 1. }. }.

Collection inject: ArgList.

;; Return the script
here.