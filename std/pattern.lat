;;* MODULE pattern
;;* PACKAGE base

pattern := $whereAmI.

;; TODO 'and' and 'or' patterns

;; Pattern matching functionality
Wildcard := Object clone.
Wildcard symbol := Nil.
Wildcard named? := { self symbol is?: Symbol. }.
Wildcard toString := {
  if (self named?)
    then { "#<Wildcard " ++ (parent self symbol) ++ ">". }
    else { "Wildcard". }.
}.
pattern Wildcard := Wildcard.

Ellipsis := Wildcard clone.
Ellipsis toString := {
  if (self named?)
     then { "#<Ellipsis " ++ (parent self symbol) ++ ">". }
     else { "Ellipsis". }.
}.
pattern Ellipsis := Ellipsis.

; The "match" object is a Proc. If no match was found, the match object is falsy and its `call`
; is a no-op. If a match was made, the object is truthy and the `call` expects a single argument,
; a method which it will evaluate after dropping in all of the matched names.
Match ::= Proc clone.
Match callback := {}.
Match call := {
  self send #'($1), #'(self callback) call.
}.
pattern Match := Match.

NoMatch ::= Match clone falsify.
NoMatch call := {}.
pattern NoMatch := NoMatch.

; * - A wildcard that matches (and ignores) anything
* := { Wildcard clone. }.
pattern * := #'(*).

; ~m 'name - A wildcard that matches anything and binds it to 'name
meta sigil m := {
  symbol := $1.
  Wildcard clone tap { self symbol := symbol. }.
}.

; ... - A wildcard that matches potentially multiple list elements and ignores them
... := { Ellipsis clone. }.
pattern ... := #'(...).

; ~m 'name ... - A wildcard that matches multiple list elements and binds the array containing them to 'name
Wildcard ... := {
  ellipsis := self clone.
  ellipsis symbol := self symbol.
  ellipsis parent := Ellipsis.
  ellipsis.
}.

; The actual matching behavior is defined here.
Object =~ := {
  if ((self) == ($1))
    then { Match clone. }
    else { NoMatch clone. }.
}.
Wildcard =~ := {
  localize.
  takes '[arg].
  if (this named?)
    then {
      Match clone tap { self callback := { $1 slot (this symbol) = #'arg. }. }.
    } else {
      Match clone.
    }.
}.

; Collection matching always binds a finite collection on the RHS to an array on the LHS. The array
; can have at most one ellipsis element.
Array =~ := {
  localize.
  takes '[rhs].
  callCC {
    escapable.
    (Collection member? (rhs)) ifFalse {
      return: NoMatch clone.
    }.
    isEllipsis := this detect { $1 is? (Ellipsis). } toBool.
    if (isEllipsis)
      then { (this size - 1) <= (rhs size). }
      else { (this size) == (rhs size). }
      ifFalse { return: NoMatch clone. }.
    afterIndex := do {
      checking := False.
      check := { parent checking := True. }.
      after := 0.
      increment := { parent after := after + 1. }.
      this visit {
        takes '[elem].
        if (checking)
          then { increment. }
          else {
            (elem is?: Ellipsis) ifTrue { check. }.
          }.
      }.
      (rhs size) - (after).
    }.
    currIndex := 0.
    currIter := rhs iterator.
    iterNext := {
      currIter next.
      parent currIndex := currIndex + 1.
    }.
    result := proc {}.
    newResult := {
      oldProc := result.
      parent result := $1: oldProc.
    }.
    sequenceResult := {
      takes '[procd].
      newResult {
        rest := $1.
        proc {
          rest call.
          procd callback.
        }.
      }.
    }.
    this visit {
      curr := $1.
      if (curr is?: Ellipsis)
        then {
          accum := Array clone.
          while { (currIndex) < (afterIndex). }
            do {
              accum pushBack: currIter element.
              iterNext.
            }.
          currMatch := (curr) =~ (accum).
          currMatch ifFalse { return currMatch. }.
          sequenceResult: currMatch.
        } else {
          currMatch := (curr) =~ (currIter element).
          currMatch ifFalse { return currMatch. }.
          sequenceResult: currMatch.
          iterNext.
        }.
    }.
    Match clone tap {
      self callback := { result call. }.
    }.
  }.
}.

Cons =~ := {
  localize.
  takes '[rhs].
  callCC {
    escapable.
    (rhs is?: Cons) ifFalse: { return: NoMatch clone. }.
    carPart := (this car) =~ (rhs car).
    cdrPart := (this cdr) =~ (rhs cdr).
    if ((carPart) and (cdrPart))
      then {
        Match clone tap {
          self callback := {
            carPart callback.
            cdrPart callback.
          }.
        }.
      } else {
        NoMatch clone.
      }.
  }.
}.

case := {
  elem := $1. ; Evaluate if a method is passed in
  Object clone tap {
    self do := {
      takes '[block].
      callCC {
        finished := $1.
        whenProc := proc {
          match := ($1) =~ (elem).
          if (match)
            then {
              Object clone tap {
                self do := {
                  result := #'$1.
                  finished call:
                    if (#'result is? (Method))
                      then { match call (#'result). }
                      else #'result.
                }.
              }.
            } else {
              Object clone tap {
                self do := { }.
              }.
            }.
        }.
        procd := Conditional send #'(block) by {
          $1 when := { whenProc call. }.
          $1 else := { self when (*) do #'$1. }.
        procd call.
        Nil.
      }.
    }.
  }.
}.
pattern case := #'case.

pattern.