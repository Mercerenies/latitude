
; TODO importAll and import behave differently if a method has the same name as a package
;      (like `format` in `format`)

;; Modules
Module ::= global clone.
Module import := {
  localize. ; TODO Import seems to be not working sometimes (in other modules)
  target := dynamic parent $lexical.
  $1 visit {
    target slot ($1) =
      {
        this slot (parent dynamic $1) me.
      }.
  }.
}.
Module importAll := {
  localize.
  target := dynamic parent $lexical.
  target parent := target parent clone.
  target := target parent.
  target missing := {
    takes '[sym].
    ; TODO This fails:
    ; if { this is (target) not. } and { this slot? (sym). }
    if { { this is (target) not. } and { this slot? (sym). }. }
      then { this slot (sym). }
      else {
        target invoke (target parent slot 'missing) call: sym.
      }.
  }.
  this.
}.
global Module := Module.

; ///// Do some more work on non-traditional objects for convenience (and definedness)
;       Ideally, we want to define absolutely no methods (save for `parent` and maybe `clone`)
;       on this NTO (non-traditional object).
global &LoadedModules := Object clone tap {
  self invoke := self slot 'invoke.
  self parent := self.
}.
&LoadedModules clone := { self invoke (Object slot 'clone) call. }.
&LoadedModules slot := { self invoke (Object slot 'slot) call. }.
&LoadedModules slot= := { self invoke (Object slot 'slot=) call. }.
&LoadedModules slot? := { self invoke (Object slot 'slot?) call. }.
&LoadedModules missing := { self invoke (Object slot 'missing) call. }.
&LoadedModules toString := "&LoadedModules".

global ModuleLoader ::= Object clone.
ModuleLoader &loaded := &LoadedModules.
ModuleLoader clone := { self invoke (Object slot 'clone) call tap { self &loaded := self &loaded clone. }. }.
ModuleLoader resolveImport := {
  takes '[imp]. ; TODO Use an environment variable for extended load path
  if (imp is (String))
    then { imp. }
    else {
      builtin := FilePath directory: Kernel executablePath.
      (builtin) ++ "std/" ++ (imp asText) ++ ".lat".
    }.
}.

global $moduleLoader := ModuleLoader clone.

; TODO Define the module name not globally but in the caller's scope to avoid polluting the global namespace
global use := {
  takes '[pname].
  fname := $moduleLoader resolveImport: pname.
  header := Kernel readHeader: fname.
  (header moduleName) ifFalse {
    err ModuleError clone tap { self message := "Module has no name". } throw.
  }.
  (header packageName) ifFalse {
    err ModuleError clone tap { self message := "Module has no package". } throw.
  }.
  name := (header packageName) ++ " " ++ (header moduleName) intern.
  if ($moduleLoader &loaded slot? (name))
    then { $moduleLoader &loaded invoke ($moduleLoader &loaded slot: name) call. }
    else {
      mod := Module clone tap { self header := header. }.
      do {
        $whereAmI := mod.
        Kernel evalFile: fname, mod.
      }.
      $moduleLoader &loaded slot (name) = mod.
      global slot (header moduleName intern) = mod.
      mod.
    }.
}.
