
;; Modules
Module := Object clone.
Module header := Nil.
Module sigils := Object clone.
Module toString := {
  if (self === Module) then {
    "Module".
  } else {
    parent self header moduleName.
  }.
}.
Module as := {
  caller slot ($1) = self.
  self.
}.
Module import := {
  localize.
  target := lexical caller.
  $1 visit {
    name := $1.
    target slot ($1) = {
      this slot (name) me.
    }.
  }.
  this.
}.
Module importAll := {
  localize.
  original := lexical caller.
  original parent := original parent clone.
  target := original parent.
  name := this header moduleName intern.
  target missing := {
    takes '[sym].
    if { this is? (target) not. } and { this slot? (sym). } then {
      this slot (sym).
    } else {
      target send (target parent slot 'missing) call: sym.
    }.
  }.
  this slot? (name) ifTrue {
    ; This is a special exceptional case where the module contains a
    ; method with the same name as itself. In order to be consistent
    ; with an explicit import of the method name, the method will take
    ; precedence over the module in this case.
    original slot (name) = this slot (name).
  }.
  this.
}.
Module importAllSigils := {
  localize.
  target := lexical caller meta sigil.
  Kernel directKeys (this sigils) visit {
    curr := $1.
    (curr == 'parent) ifFalse {
      target slot (curr) = this sigils slot (curr).
    }.
  }.
  this.
}.
global Module := Module.

global ModuleLoader ::= Object clone.
ModuleLoader loaded := [=>].
ModuleLoader clone := {
  self send (Object slot 'clone) call tap {
    self loaded := self loaded dup.
  }.
}.
ModuleLoader loadPath := do {
  arr := [].
  arr pushBack: FilePath directory (Kernel executablePath) ++ "std/".
  arr pushBack: Kernel cwd ++ "/".
  path := Kernel env "LATITUDE_PATH".
  path ifTrue {
    path split ";" visit {
      arr pushBack: $1.
    }.
  }.
  arr.
}.
ModuleLoader resolveImport := {
  takes '[imp].
  localize.
  if (imp is? (String)) then {
    imp.
  } else {
    callCC {
      escapable.
      this loadPath visit {
        curr := $1 ++ (imp asText) ++ ".lat".
        { Stream exists? (curr). } or { Stream exists? (curr ++ "c"). } ifTrue {
          return: curr.
        }.
      }.
      err ModuleError clone tap {
        self message := "Cannot find module " ++ (imp).
      } throw.
    }.
  }.
}.

global $moduleLoader := ModuleLoader clone.

global use := {
  takes '[pname].
  target := lexical caller.
  fname := $moduleLoader resolveImport: pname.
  header := Kernel readHeader: fname.
  (header moduleName) ifFalse {
    err ModuleError clone tap { self message := "Module has no name". } throw.
  }.
  (header packageName) ifFalse {
    err ModuleError clone tap { self message := "Module has no package". } throw.
  }.
  name := ((header packageName) ++ " " ++ (header moduleName)) intern.
  mod := Nil.
  assignable 'mod.
  if ($moduleLoader loaded has? (name)) then {
    mod = $moduleLoader loaded get (name).
  } else {
    mod = Module clone tap { self header := header. }.
    do {
      $whereAmI := mod.
      scope := global clone.
      scope meta := scope meta clone.
      scope meta meta := scope meta.
      scope meta sigil := scope meta sigil clone.
      mod = Kernel evalFile: fname, scope.
    }.
    $moduleLoader loaded get (name) = mod.
  }.
  target slot (header moduleName intern) = mod.
  mod.
}.
