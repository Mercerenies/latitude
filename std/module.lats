
;; Modules
Module ::= global clone.
Module header := Nil.
Module import := {
  localize.
  target := lexical caller.
  $1 visit {
    name := $1.
    target slot ($1) = {
      this slot (name) me.
    }.
  }.
}.
Module importAll := {
  localize.
  target := lexical caller.
  target parent := target parent clone.
  target := target parent.
  name := this header moduleName intern.
  target missing := {
    takes '[sym].
    ; TODO This fails:
    ; if { this is (target) not. } and { this slot? (sym). }
    if { { this is (target) not. } and { this slot? (sym). }. }
      then { this slot (sym). }
      else {
        target invoke (target parent slot 'missing) call: sym.
      }.
  }.
  this slot? (name) ifTrue {
    ; This is a special exceptional case where the module contains a
    ; method with the same name as itself. In order to be consistent
    ; with an explicit import of the method name, the method will take
    ; precedence over the module in this case.
    target slot (name) = this slot (name).
  }.
  this.
}.
global Module := Module.

; TODO Can a self-evaluating object be a parent of something else? If so, what does its hierarchy look like?

global &LoadedModules := Object clone tap {
  self parent := self.
  self toString := "&LoadedModules".
}.

global ModuleLoader ::= Object clone.
ModuleLoader &loaded := &LoadedModules.
ModuleLoader clone := {
  self invoke (Object slot 'clone) call tap {
    self &loaded := Kernel cloneObject: self &loaded.
  }.
}.
ModuleLoader loadPath := do {
  exec := FilePath directory (Kernel executablePath) ++ "std/".
  cwd := Kernel cwd ++ "/".
  [exec, cwd].
}.
ModuleLoader resolveImport := {
  takes '[imp].
  localize.
  if (imp is (String)) then {
    imp.
  } else {
    callCC {
      escapable.
      this loadPath visit {
        curr := $1 ++ (imp asText) ++ ".lat".
        Stream exists? (curr) ifTrue {
          return: curr.
        }.
      }.
      err ModuleError clone tap {
        self message := "Cannot find module " ++ (imp).
      } throw.
    }.
  }.
}.

global $moduleLoader := ModuleLoader clone.

; TODO Define the module name not globally but in the caller's scope to avoid polluting the global namespace
global use := {
  takes '[pname].
  fname := $moduleLoader resolveImport: pname.
  header := Kernel readHeader: fname.
  (header moduleName) ifFalse {
    err ModuleError clone tap { self message := "Module has no name". } throw.
  }.
  (header packageName) ifFalse {
    err ModuleError clone tap { self message := "Module has no package". } throw.
  }.
  name := (header packageName) ++ " " ++ (header moduleName) intern.
  if (Kernel Slots has? ($moduleLoader &loaded, name))
    then { Kernel Slots hold ($moduleLoader &loaded, name). }
    else {
      mod := Module clone tap { self header := header. }.
      do {
        $whereAmI := mod.
        Kernel evalFile: fname, mod.
      }.
      Kernel Slots put: $moduleLoader &loaded, name, mod.
      global slot (header moduleName intern) = mod.
      mod.
    }.
}.
