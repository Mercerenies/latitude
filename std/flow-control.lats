
;; Continuations
Cont call := { meta sys exitCC#: self, #'$1. }.
Cont toString := "Cont".
global callCC := {
  meta sys callCC#: Cont clone, #'$1.
}.
global escapable := {
  cont := $1.
  caller return := { cont call. }.
}.

;; Booleans
Object toBool := True.
False toBool := False.
Nil toBool := False.
Object true? := False.
True true? := True.
Object false? := False.
False false? := True.
Object nil? := False.
Nil nil? := True.
Boolean toString := "Boolean".
True toString := "True".
False toString := "False".
Nil toString := "Nil".
Object falsify := {
  #'self toBool := False.
  #'self.
}.

;; Control Statements
Conditional ::= Object clone.
global if := {
  truthy := Conditional invoke #'$1 call toBool.
  Object clone tap {
    self then := {
      trueCase := #'$1.
      Object clone tap {
        self else := {
          falseCase := #'$1.
          ; TODO We'd like ifThenElse# to use the global symbol table's true value,
          ; not the True variable.
          meta sys ifThenElse#:
            True,
            truthy,
            { Conditional invoke #'trueCase call. },
            { Conditional invoke #'falseCase call. }.
        }.
      }.
    }.
  }.
}.
Object ifTrue := {
  content := #'$1.
  if (self) then { Kernel invokeOn (parent slot 'self, #'content) call. } else { Nil. }.
  #'self.
}.
Object ifFalse := {
  content := #'$1.
  if (self) then { Nil. } else { Kernel invokeOn (parent slot 'self, #'content) call. }.
  #'self.
}.
Object and := {
  if (self) then #'$1 else { False. }.
}.
Object or := {
  fst := self.
  if (fst) then { fst. } else #'$1.
}.
Object not := {
  if (self) then { False. } else { True. }.
}.

;; Loops
;; TODO Make `self` on these methods well-defined.
global loop := {
  meta sys loopDo#: #'$1.
; restart := callCC { $1. }.
; $1.
; restart call: restart.
}.
global while := {
  cond := #'$1.
  Object clone tap {
    self do := {
      stmt := #'$1.
      callCC {
        escapable.
        $break := #'return.
        loop {
          if (cond)
            then { stmt. }
            else { $break: Nil. }.
        }.
      }.
    }.
  }.
}.

Number times := {
  localize.
  block := #'$1.
  i := 0.
  incr := {
    parent i := i + 1.
  }.
  while { (i) < (this). } do {
    block (i).
    incr.
  }.
}.
Number upto := {
  localize.
  takes '[n].
  Object clone tap {
    self do := {
      block := #'$1.
      i := this.
      incr := { parent i := i + 1. }.
      while { (i) < (n). } do {
        block (i).
        incr.
      }.
    }.
  }.
}.
Number downto := {
  localize.
  takes '[n].
  Object clone tap {
    self do := {
      block := #'$1.
      i := this.
      decr := {
        parent i := i - 1.
      }.
      while { (i) > (n). } do {
        block (i).
        decr.
      }.
    }.
  }.
}.

;; Cond Statement
global cond := {
  takes '[block].
  callCC {
    finished := $1.
    whenProc := proc {
      if ($1)
        then {
          Object clone tap {
            self do := { finished call: $1. }.
          }.
        } else {
          Object clone tap {
            self do := { }.
          }.
        }.
    }.
    procd := $dynamic invokeSpecial:
      #'block,
      {
        $1 when := { whenProc call. }.
        $1 else := { self when (True) do #'$1. }.
      }.
    procd call.
    Nil.
  }.
}.

;; Return the script
here.
