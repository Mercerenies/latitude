;;* MODULE monad
;;* PACKAGE base

; TODO Either remove this package or make it waaaaaaaaay more efficient; the current
;      `meta statements` is obviously not built for this kind of stress.

; TODO Monad transformers...?

use 'util.

; A monad implementation is expected to have the following methods
; * pure - A method of one argument that wraps the value in the monad
; * fmap - A method of two argument, a method and a monadic value, which maps the method over the structure
; * join - A method of one argument, which operates on a nested monad to merge it
Monad ::= Mixin clone.
Monad interface := '[bind, seq, call].

; `monad bind: obj, { mthd. }.` runs the method given the internals of `obj`.
Monad bind := { self join: self fmap (#'$2, $1). }.
; `monad seq: obj1, obj2.` combines the first and second contexts.
Monad seq := { self bind: $1, #'$2. }.
; `monad call @{ code. }.` performs the code within the monadic context provided.
Monad call := {
  localize.
  $binder := Nil.
  $binder= := { dynamic origin '$binder $binder := $1. }.
  $varBomb := { }.
  newVariable := {
    oldBomb := $1 hold '$varBomb.
    $1 $varBomb := {
      oldBomb.
      $1 put: parent dynamic $2, parent dynamic $3.
    }.
  }.
  prepare := {
    $varBomb.
    $1 context := this.
    $1 put: '<-, {
      $binder = $1.
      $2.
    }.
  }.
  iter0 := #'$1 statements iterator.
  continue := {
    takes '[iter, value].
    if (iter end?)
      then { Nil. }
      else {
        elem := iter element.
        $binder ifTrue {
          newVariable: parent dynamic, $binder, value.
        }.
        $binder := Nil.
        result := (elem invokeSpecial: (elem hold 'call), #'prepare) call.
        ; It is necessary not to destroy the iterator in case the monad
        ; wishes to branch or perform multiple executions
        iter1 := iter clone tap { self next. }.
        if (iter1 end?)
          then { result. }
          else {
            this bind: result, { continue: iter1, $1. }.
          }.
      }.
  }.
  continue: iter0, Nil.
}.

IdMonad ::= Object clone.
IdMonad pure := { #'$1. }.
IdMonad fmap := { $1: #'$2. }.
IdMonad join := { #'$1. }.
Monad inject: IdMonad.

Maybe := Object clone.
Maybe value := Nil.
Maybe toString := {
  if ((self) === (Maybe))
    then "Maybe"
    else "#<Maybe (Just " ++ (self value toString) ++ ")>".
}.
Nothing ::= Maybe clone falsify.
just := {
  Maybe clone tap { self value := parent dynamic hold '$1. }.
}.
MaybeMonad ::= Object clone.
MaybeMonad pure := { just. }.
MaybeMonad fmap := {
  takes '[mthd, obj].
  if (obj is (Nothing))
    then { obj. }
    else { just: mthd (obj value). }.
}.
MaybeMonad join := {
  takes '[obj].
  if { obj is (Nothing). }
    then { obj. }
    else { obj value. }.
}.
Monad inject: MaybeMonad.

IterMonad ::= Object clone.
IterMonad pure := {
  util Cell clone tap { self value := parent dynamic hold '$1. }.
}.
IterMonad fmap := { $2 map. }.
IterMonad join := { $1 foldl: Nil, '<> toProc. }.
Monad inject: IterMonad.

$whereAmI.