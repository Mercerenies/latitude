;;* MODULE util
;;* PACKAGE base

;; "Cells" a la MIT Scheme
Cell := Object clone.
Cell value := Nil.
Cell toString := "Cell".

;; Cells are also iterable
Cell iterator := {
  CellIterator := Object clone.
  CellIterator toString := "CellIterator".
  CellIterator cell := self.
  CellIterator end? := False.
  CellIterator next := { self end? := True. }.
  CellIterator element := { self cell value. }.
  CellIterator element= := { self cell value := dynamic hold '$1. }.
  CellIterator.
}.
Collection inject: Cell.

;; Lockboxes and Latchkeys
Latchkey := Object clone.
Lockbox := Object clone.
Latchkey tag := Symbol.
Latchkey make := {
  key := self clone.
  key tag := key tag gensymOf: "KEY".
  key.
}.
Lockbox store := { self put: $1 tag, $2. }.
Lockbox fits := { self has: $1 tag. }.
Lockbox retrieve := {
  if { parent self fits: parent dynamic $1. }
    then { parent self get: parent dynamic $1 tag. }
    else { Nil. }.
}.
Lockbox toString := "Lockbox".
Latchkey toString := "Latchkey".
Latchkey pretty := { "Key " ++ (self tag pretty). }.
Latchkey == := { (self tag) == (self tag). }.

;; Python-style generator functions
; Note that currently, generators are single-pass.
; Example usage:
; { $yield 1. $yield 2. } generator toArray.
;    ==> [1, 2]
; TODO Figure out how to make generators clone-able to make them multi-pass
;      (something bizarre is happening between the continuation jumps when a clone is used)
Generator := Proc clone.
Generator toString := "Generator".
Generator iterator := { self. }.
Generator end? := True.
Generator element := Nil.
Generator element= := {
  err ReadOnlyError clone tap { self message := "Generators are read-only". } throw.
}.
Generator next := { }.
Generator call := {
  self next.
  self element.
}.
Generator map := {
  localize.
  procd := proc { parent dynamic hold '$1 call. }.
  {
    this visit { $yield: procd call ($1). }.
  } generator.
}.
Proc generator := {
  procd := proc { parent hold 'self call. }.
  Generator clone tap {
    self end? := False.
    self element := Nil.
    self yieldStmt := Nil.
    self resumeStmt := {
      localize.
      proc {
        this procStmt call.
        this end? := True.
        this yieldStmt call: Nil.
      }.
    }.
    self procStmt := {
      localize.
      procd invokeSpecial:
        { procd call. },
        {
          $2 $yield := {
            takes '[result].
            parent this := callCC {
              this resumeStmt := $1.
              this yieldStmt call: result.
            }.
          }.
        }.
    }.
    self next := {
      localize.
      callCC {
        outer := $1.
        this element := callCC {
          this yieldStmt := $1.
          this element := this resumeStmt call: this.
          this end? := True.
          outer call: Nil.
        }.
      }.
    }.
    self next.
  }.
}.
Collection inject: Generator.

;; McCarthy's 'amb' operator
; Example usage:
; callAmb { x := amb [1, 2, 3].
;           y := amb [2, 4, 6].
;           ((x) * (y) == 8) ifFalse: { amb []. }.
;           [x, y]. }.
; TODO This one is a bit sloppy when it's cloned as well; work on that
AmbError := Exception clone tap { self toString := "AmbError".
                                  self message := "Amb expression failed". }.
Amb := Object clone.
Amb toString := "Amb".
Amb nextHandler := { AmbError clone throw. }.
callAmb := {
  ambObject := Amb clone.
  ambFunc := proc {
    takes '[cases].
    callCC {
      escape := { parent dynamic $1 call. }.
      oldHandler := ambObject hold 'nextHandler.
      cases visit {
        takes '[curr].
        callCC {
          ambObject nextHandler := { parent dynamic $1 call. }.
          escape: curr.
        }.
      }.
      oldHandler.
    }.
  }.
  procd := ambObject invokeSpecial:
    dynamic hold '$1,
    { $1 amb := { ambFunc call. }. }.
  procd call.
}.

;; Accumulator, similar to Haskell's Writer monad
;; Example usage:
; accumulate { tell 1.
;              tell 2.
;              tell 3. }.
; Results in [1, 2, 3]
accumulate := {
  result := Array clone.
  procd := result invokeSpecial:
    dynamic hold '$1,
    {
      $1 tell := { result pushBack. }.
      $1 tellAll := { $1 visit { result pushBack. }. }.
    }.
  procd call.
  result.
}.

;; Return the script
$whereAmI.