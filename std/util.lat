
ReadOnlyError := ReadOnlyError.
ArgList := ArgList.
Proc := Proc.
proc := hold 'proc.

;; "Cells" a la MIT Scheme
global Cell := Object clone.
Cell value := Nil.
Cell toString := "Cell".

;; Lockboxes and Latchkeys
global Latchkey := Object clone.
global Lockbox := Object clone.
Latchkey tag := Symbol.
Latchkey make := { key := self clone.
                   key tag := key tag gensymOf: "KEY".
                   key. }.
Lockbox store := { self put: $1 tag, $2. }.
Lockbox fits := { self has: $1 tag. }.
Lockbox retrieve := { if: { parent self fits: parent dynamic $1. },
                          { parent self get: parent dynamic $1 tag. },
                          { meta Nil. }. }.
Lockbox toString := "Lockbox".
Latchkey toString := "Latchkey".
Latchkey pretty := { "Key " ++ (self tag pretty). }.
Latchkey == := { (self tag) == (self tag). }.

; Dumping and Printing Convenience Functions
stdout := stdout.
Stream dump := { localize.
                 obj := dynamic hold '$1.
                 this println: obj.
                 obj keys visit { this putln: "  " ++ ($1 asText) ++ ": " ++ ((obj hold: $1) toString). }.
                 meta Nil. }.
Object println := { stdout println: hold 'self. }.
Object dump := { stdout dump: hold 'self. }.

; It's very easy to lose track of a `self` in nested method calls, and calling `parent` repeatedly
; can be annoying, so the `localize` method will bind `this` to `self` in the calling scope. `this`
; will not rebind lexically until that scope exits.
global this := { dynamic parent $lexical self. }.
global localize := { dynamic parent $lexical this := dynamic parent $lexical self. }.

; Likewise, the dynamic argument behavior occasonally gets in the way, so this is provided to rebind
; dynamic arguments to lexical names. It expects a list of symbols (usually a literal list). The name
; `takes` implies that the method in question takes these arguments. It is designed to be read in English,
; as it is usually the first line of a method (possibly the second, after a `localize`).
global takes := { args := ArgList clone fillWith: dynamic parent.
                  target := dynamic parent $lexical.
                  ($1 clone zip!: args) map!: { target put: ($1 car), ($1 hold 'cdr). $1 car. }. }.

;; Python-style generator functions
; Note that currently, generators are single-pass.
; TODO Figure out how to make generators clone-able to make them multi-pass
;      (something bizarre is happening between the continuation jumps when a clone is used)
Generator := Proc clone.
Generator toString := "Generator".
Generator iterator := { self. }.
Generator end? := True.
Generator element := Nil.
Generator element= := { ReadOnlyError clone tap { self message := "Generators are read-only". } throw. }.
Generator next := { }.
Generator call := { self next.
                    self element. }.
Generator map := { localize.
                   procd := proc { parent dynamic hold '$1 call. }.
                   { this visit { $yield: procd call ($1). }. } generator. }.
Proc generator := { procd := proc { parent hold 'self call. }.
                    Generator clone tap { self end? := False.
                                          self element := Nil.
                                          self yieldStmt := Nil.
                                          self resumeStmt := { localize.
                                                               proc { this procStmt call.
                                                                      this end? := True.
                                                                      this yieldStmt call: Nil. }. }.
                                          self procStmt :=
                                              { localize.
                                                procd invokeSpecial:
                                                    { procd call. },
                                                    { $2 $yield :=
                                                          { takes '[result].
                                                            parent this := callCC
                                                                        { this resumeStmt := $1.
                                                                          this yieldStmt call: result. }. }. }. }.
                                          self next :=
                                              { localize.
                                                callCC { outer := $1.
                                                         this element :=
                                                             callCC { this yieldStmt := $1.
                                                                      this element := this resumeStmt call: this.
                                                                      this end? := True.
                                                                      outer call: Nil. }. }. }.
                                          self next. }. }.
global Generator := Generator.
Collection inject: Generator.

;; Return the script
here.