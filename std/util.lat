
ArgList := ArgList.

;; "Cells" a la MIT Scheme
global Cell := Object clone.
Cell value := Nil.
Cell toString := "Cell".

;; Lockboxes and Latchkeys
global Latchkey := Object clone.
global Lockbox := Object clone.
Latchkey tag := Symbol.
Latchkey make := { key := self clone.
                   key tag := key tag gensymOf: "KEY".
                   key. }.
Lockbox store := { self put: $1 tag, $2. }.
Lockbox fits := { self has: $1 tag. }.
Lockbox retrieve := { if: { parent self fits: parent dynamic $1. },
                          { parent self get: parent dynamic $1 tag. },
                          { meta Nil. }. }.
Lockbox toString := "Lockbox".
Latchkey toString := "Latchkey".
Latchkey pretty := { "Key " ++ (self tag pretty). }.
Latchkey == := { (self tag) == (self tag). }.

; Dumping and Printing Convenience Functions
stdout := stdout.
Stream dump := { localize.
                 obj := dynamic hold '$1.
                 this println: obj.
                 obj keys visit { this putln: "  " ++ ($1 asText) ++ ": " ++ ((obj hold: $1) toString). }.
                 meta Nil. }.
Object println := { stdout println: hold 'self. }.
Object dump := { stdout dump: hold 'self. }.

; It's very easy to lose track of a `self` in nested method calls, and calling `parent` repeatedly
; can be annoying, so the `localize` method will bind `this` to `self` in the calling scope. `this`
; will not rebind lexically until that scope exits.
global this := { dynamic parent $lexical self. }.
global localize := { dynamic parent $lexical this := dynamic parent $lexical self. }.

; Likewise, the dynamic argument behavior occasonally gets in the way, so this is provided to rebind
; dynamic arguments to lexical names. It expects a list of symbols (usually a literal list). The name
; `takes` implies that the method in question takes these arguments. It is designed to be read in English,
; as it is usually the first line of a method (possibly the second, after a `localize`).
global takes := { args := ArgList clone fillWith: dynamic parent.
                  target := dynamic parent $lexical.
                  ($1 clone zip!: args) map!: { target put: ($1 car), ($1 hold 'cdr). $1 car. }. }.

;; Return the script
here.