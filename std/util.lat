
;; "Cells" a la MIT Scheme
global Cell := Object clone.
Cell value := Nil.
Cell toString := "Cell".

;; Lockboxes and Latchkeys
global Latchkey := Object clone.
global Lockbox := Object clone.
Latchkey tag := Symbol.
Latchkey make := { key := self clone.
                   key tag := key tag gensymOf: "KEY".
                   key. }.
Lockbox store := { self put: $1 tag, $2. }.
Lockbox fits := { self has: $1 tag. }.
Lockbox retrieve := { if: { parent self fits: parent dynamic $1. },
                          { parent self get: parent dynamic $1 tag. },
                          { meta Nil. }. }.
Lockbox toString := "Lockbox".
Latchkey toString := "Latchkey".
Latchkey pretty := { "Key " ++ (self tag pretty). }.
Latchkey == := { (self tag) == (self tag). }.

; It's very easy to lose track of a `self` in nested method calls, and calling `parent` repeatedly
; can be annoying, so the `localize` method will bind `this` to `self` in the calling scope. `this`
; will not rebind lexically until that scope exits.
global this := { dynamic parent $lexical self. }.
global localize := { dynamic parent $lexical this := dynamic parent $lexical self. }.

;; Return the script
here.