;;* MODULE util
;;* PACKAGE base

ReadOnlyError := ReadOnlyError.
ArgList := ArgList.
Proc := Proc.
proc := hold 'proc.
Exception := Exception.

;; "Cells" a la MIT Scheme
global Cell := Object clone.
Cell value := Nil.
Cell toString := "Cell".

;; Lockboxes and Latchkeys
global Latchkey := Object clone.
global Lockbox := Object clone.
Latchkey tag := Symbol.
Latchkey make := { key := self clone.
                   key tag := key tag gensymOf: "KEY".
                   key. }.
Lockbox store := { self put: $1 tag, $2. }.
Lockbox fits := { self has: $1 tag. }.
Lockbox retrieve := { if: { parent self fits: parent dynamic $1. },
                          { parent self get: parent dynamic $1 tag. },
                          { meta Nil. }. }.
Lockbox toString := "Lockbox".
Latchkey toString := "Latchkey".
Latchkey pretty := { "Key " ++ (self tag pretty). }.
Latchkey == := { (self tag) == (self tag). }.

; Dumping and Printing Convenience Functions
stdout := stdout.
Stream dump := { localize.
                 obj := dynamic hold '$1.
                 this println: obj.
                 obj keys visit { this putln: "  " ++ ($1 asText) ++ ": " ++ ((obj hold: $1) toString). }.
                 meta Nil. }.
Object println := { stdout println: hold 'self. }.
Object dump := { stdout dump: hold 'self. }.

;; Python-style generator functions
; Note that currently, generators are single-pass.
; Example usage:
; { $yield 1. $yield 2. } generator toArray.
;    ==> [1, 2]
; TODO Figure out how to make generators clone-able to make them multi-pass
;      (something bizarre is happening between the continuation jumps when a clone is used)
Generator := Proc clone.
Generator toString := "Generator".
Generator iterator := { self. }.
Generator end? := True.
Generator element := Nil.
Generator element= := { ReadOnlyError clone tap { self message := "Generators are read-only". } throw. }.
Generator next := { }.
Generator call := { self next.
                    self element. }.
Generator map := { localize.
                   procd := proc { parent dynamic hold '$1 call. }.
                   { this visit { $yield: procd call ($1). }. } generator. }.
Proc generator := { procd := proc { parent hold 'self call. }.
                    Generator clone tap { self end? := False.
                                          self element := Nil.
                                          self yieldStmt := Nil.
                                          self resumeStmt := { localize.
                                                               proc { this procStmt call.
                                                                      this end? := True.
                                                                      this yieldStmt call: Nil. }. }.
                                          self procStmt :=
                                              { localize.
                                                procd invokeSpecial:
                                                    { procd call. },
                                                    { $2 $yield :=
                                                          { takes '[result].
                                                            parent this := callCC
                                                                        { this resumeStmt := $1.
                                                                          this yieldStmt call: result. }. }. }. }.
                                          self next :=
                                              { localize.
                                                callCC { outer := $1.
                                                         this element :=
                                                             callCC { this yieldStmt := $1.
                                                                      this element := this resumeStmt call: this.
                                                                      this end? := True.
                                                                      outer call: Nil. }. }. }.
                                          self next. }. }.
global Generator := Generator.
Collection inject: Generator.

;; McCarthy's 'amb' operator
; Example usage:
; callAmb { x := amb [1, 2, 3].
;           y := amb [2, 4, 6].
;           ((x) * (y) == 8) ifFalse: { amb []. }.
;           [x, y]. }.
; TODO This one is a bit sloppy when it's cloned as well; work on that
AmbError := Exception clone tap { self toString := "AmbError".
                                  self message := "Amb expression failed". }.
global AmbError := AmbError.
Amb := Object clone.
global Amb := Amb.
Amb toString := "Amb".
Amb nextHandler := { AmbError clone throw. }.
global callAmb := { ambObject := Amb clone.
                    ambFunc := proc { takes '[cases].
                                      callCC { escape := { parent dynamic $1 call. }.
                                               oldHandler := ambObject hold 'nextHandler.
                                               cases visit
                                                   { takes '[curr].
                                                     callCC { ambObject nextHandler := { parent dynamic $1 call. }.
                                                              escape: curr. }. }.
                                               oldHandler. }. }.
                    procd := ambObject invokeSpecial: dynamic hold '$1,
                                                      { $1 amb := { ambFunc call. }. }.
                    procd call. }.

;; Return the script
here.