;;* MODULE util
;;* PACKAGE base

util := $whereAmI.

;; "Cells" a la MIT Scheme
Cell := Object clone.
Cell valueCell := Nil.
Cell value := { #'(self valueCell). }.
Cell value= := { self valueCell := #'$1. }.
Cell toString := {
  localize.
  if (this === Cell) then {
    "Cell".
  } else {
    "#<Cell " ++ this value ++ ">".
  }.
}.
Cell make := {
  target := #'$1.
  self clone tap {
    self value = #'target.
  }.
}.
util Cell := Cell.

;; Cells are also iterable
Cell iterator := {
  CellIterator := Object clone.
  CellIterator toString := "CellIterator".
  CellIterator cell := self.
  CellIterator end? := False.
  CellIterator next := { self end? := True. }.
  CellIterator element := { self cell value. }.
  CellIterator element= := { self cell value := #'$1. }.
  CellIterator.
}.
Collection inject: Cell.

;; Lockboxes and Latchkeys
Latchkey := Object clone.
Lockbox := Object clone.
Latchkey tag := Symbol.
Latchkey make := {
  key := self clone.
  key tag := key tag gensymOf: "KEY".
  key.
}.
Lockbox store := { self slot ($1 tag) = $2. }.
Lockbox fits := { self slot? ($1 tag). }.
Lockbox retrieve := {
  key := $1.
  if { parent self fits: key. }
    then { parent self slot: key tag. }
    else { Nil. }.
}.
Lockbox toString := "Lockbox".
Latchkey toString := "Latchkey".
Latchkey pretty := { "Key " ++ (self tag pretty). }.
Latchkey == := { (self tag) == (self tag). }.

util Latchkey := Latchkey.
util Lockbox := Lockbox.

;; Python-style generator functions
; Example usage:
; { $yield 1. $yield 2. } generator toArray.
;    ==> [1, 2]
Generator := Proc clone.
Generator toString := "Generator".
Generator clone := {
  localize.
  this invoke (Object slot 'clone) call tap {
    self end? := this end?.
    self element := this element.
  }.
}.
Generator iterator := { self clone. }.
Generator state := Nil.
Generator end? := True.
Generator element := Nil.
Generator element= := {
  err ReadOnlyError clone tap { self message := "Generators are read-only". } throw.
}.
Generator next := { }.
Generator call := {
  self next.
  self element.
}.
Generator map := {
  func0 := #'$1.
  procd := proc { #'func0 call. }.
  {
    while { $state end? not. } do {
      $yield: procd call ($state element).
      $state next.
    }.
  } generatorWith (self iterator) tap {
    self clone := {
      old := self.
      self invoke (Generator slot 'clone) call tap {
        self state := old state clone.
      }.
    }.
  }.
}.
Proc generatorWith := {
  takes '[state].
  procd := proc { parent slot 'self call. }.
  Generator clone tap {
    self end? := False.
    self element := Nil.
    self state := state.
    self yieldStmt := Nil.
    self resumeStmt := {
      localize.
      proc {
        this := this procStmt call.
        this end? := True.
        this yieldStmt call: Nil.
      }.
    }.
    self procStmt := {
      localize.
      'this assign = { $1. }.
      procd invokeSpecial:
        {
          procd call.
          this.
        },
        {
          $2 $yield := {
            takes '[result].
            this = callCC {
              this resumeStmt := $1.
              this yieldStmt call: result.
            }.
          }.
          $2 $state := { this state. }.
        }.
    }.
    self next := {
      localize.
      this element := callCC {
        this yieldStmt := $1.
        this element := this resumeStmt call: this.
        Nil.
      }.
    }.
    self next.
  }.
}.
Proc generator := { #'self generatorWith (Nil). }.
Collection inject: Generator.

util Generator := Generator.

;; McCarthy's 'amb' operator
; Example usage:
; callAmb { x := amb [1, 2, 3].
;           y := amb [2, 4, 6].
;           ((x) * (y) == 8) ifFalse: { amb []. }.
;           [x, y]. }.
AmbError := Exception clone tap { self toString := "AmbError".
                                  self message := "Amb expression failed". }.
Amb := Object clone.
Amb toString := "Amb".
Amb nextHandler := { AmbError clone throw. }.
callAmb := {
  ambObject := Amb clone.
  ambFunc := proc {
    takes '[cases].
    callCC {
      escapable.
      oldHandler := ambObject slot 'nextHandler.
      cases visit {
        takes '[curr].
        callCC {
          nextExit := #'$1.
          ambObject nextHandler := { nextExit call. }.
          return: curr.
        }.
      }.
      oldHandler.
    }.
  }.
  procd := ambObject invokeSpecial:
    #'$1,
    { $1 amb := { ambFunc call. }. }.
  procd call.
}.

util Amb := Amb.
util callAmb := #'callAmb.

;; Accumulator, similar to Haskell's Writer monad
;; Example usage:
; accumulate { tell 1.
;              tell 2.
;              tell 3. }.
; Results in [1, 2, 3]
accumulate := {
  result := Array clone.
  procd := result invokeSpecial:
    #'$1,
    {
      $1 tell := { result pushBack. }.
      $1 tellAll := { $1 visit { result pushBack. }. }.
    }.
  procd call.
  result.
}.

util accumulate := #'accumulate.

;; Return the script
util.
