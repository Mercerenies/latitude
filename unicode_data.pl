#!/usr/bin/perl

use strict;
use warnings;
use 5.010;

my @classes = qw{
    Lu Ll Lt Lm Lo Mn Mc Me Nd Nl No Pc Pd
    Ps Pe Pi Pf Po Sm Sc Sk So Zs Zl Zp Cc
    Cf Cs Co Cn
};

my $curr = '';
my $start;
my %classes;
my @data;

open my $fh, '<', './misc/uni/UnicodeData.txt';
while (<$fh>) {
    my @line = split /;/;
    if ($curr ne $line[2]) {
        if ($curr ne '') {
            my %value = (
                start => $start  ,
                end   => $line[0],
                class => $curr
                );
            push @data, \%value;
            ++$classes{$curr};
        }
        $start = $line[0];
        $curr = $line[2];
    }
}
close($fh);

if ($ARGV[0] eq 'header') {

    local $" = ",\n    ";
    my @enum_contents = map { "UNICLS_@{[uc]}" } @classes;

    print <<"END_CC";

// This file is generated by unicode_data.pl. Do not modify by hand.

#ifndef PL_UNIDATA_H
#define PL_UNIDATA_H

#ifdef __cplusplus
extern "C" {
#endif

enum uni_class_t {
    @enum_contents
};

enum uni_class_t get_class(int codepoint);

#ifdef __cplusplus
}
#endif

#endif // PL_UNIDATA_H

END_CC

} elsif ($ARGV[0] eq 'source') {

    local $" = ",\n    ";
    my @block_data = map { "{ 0x$_->{start}, 0x$_->{end}, UNICLS_@{[uc $_->{class}]} }" } @data;

    print <<"END_CC";

// This file is generated by unicode_data.pl. Do not modify by hand.

#include "pl_Unidata.h"

struct block_data_t {
    long start;
    long end;
    enum uni_class_t class;
};

static struct block_data_t all_block_data[] = {
    @block_data
};
static const int BLOCK_COUNT = @{[scalar @block_data]};

struct block_data_t* get_block(long codepoint) {
    int begin = 0;
    int end = BLOCK_COUNT;
    while (1) {
        int pivot = (begin + end) / 2;
        if (codepoint < all_block_data[pivot].start) {
            end = pivot;
        } else if (codepoint > all_block_data[pivot].end) {
            begin = pivot;
        } else {
            return &all_block_data[pivot];
        }
    }
}

enum uni_class_t get_class(int codepoint) {
    return get_block(codepoint)->class;
}

END_CC

} else {
    die("Unknown argument $ARGV[0]");
}
